"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.se_GetFieldLevelEncryptionProfileCommand = exports.se_GetFieldLevelEncryptionConfigCommand = exports.se_GetFieldLevelEncryptionCommand = exports.se_GetDistributionConfigCommand = exports.se_GetDistributionCommand = exports.se_GetContinuousDeploymentPolicyConfigCommand = exports.se_GetContinuousDeploymentPolicyCommand = exports.se_GetCloudFrontOriginAccessIdentityConfigCommand = exports.se_GetCloudFrontOriginAccessIdentityCommand = exports.se_GetCachePolicyConfigCommand = exports.se_GetCachePolicyCommand = exports.se_DescribeKeyValueStoreCommand = exports.se_DescribeFunctionCommand = exports.se_DeleteStreamingDistributionCommand = exports.se_DeleteResponseHeadersPolicyCommand = exports.se_DeleteRealtimeLogConfigCommand = exports.se_DeletePublicKeyCommand = exports.se_DeleteOriginRequestPolicyCommand = exports.se_DeleteOriginAccessControlCommand = exports.se_DeleteMonitoringSubscriptionCommand = exports.se_DeleteKeyValueStoreCommand = exports.se_DeleteKeyGroupCommand = exports.se_DeleteFunctionCommand = exports.se_DeleteFieldLevelEncryptionProfileCommand = exports.se_DeleteFieldLevelEncryptionConfigCommand = exports.se_DeleteDistributionCommand = exports.se_DeleteContinuousDeploymentPolicyCommand = exports.se_DeleteCloudFrontOriginAccessIdentityCommand = exports.se_DeleteCachePolicyCommand = exports.se_CreateStreamingDistributionWithTagsCommand = exports.se_CreateStreamingDistributionCommand = exports.se_CreateResponseHeadersPolicyCommand = exports.se_CreateRealtimeLogConfigCommand = exports.se_CreatePublicKeyCommand = exports.se_CreateOriginRequestPolicyCommand = exports.se_CreateOriginAccessControlCommand = exports.se_CreateMonitoringSubscriptionCommand = exports.se_CreateKeyValueStoreCommand = exports.se_CreateKeyGroupCommand = exports.se_CreateInvalidationCommand = exports.se_CreateFunctionCommand = exports.se_CreateFieldLevelEncryptionProfileCommand = exports.se_CreateFieldLevelEncryptionConfigCommand = exports.se_CreateDistributionWithTagsCommand = exports.se_CreateDistributionCommand = exports.se_CreateContinuousDeploymentPolicyCommand = exports.se_CreateCloudFrontOriginAccessIdentityCommand = exports.se_CreateCachePolicyCommand = exports.se_CopyDistributionCommand = exports.se_AssociateAliasCommand = void 0;
exports.se_UpdateDistributionWithStagingConfigCommand = exports.se_UpdateDistributionCommand = exports.se_UpdateContinuousDeploymentPolicyCommand = exports.se_UpdateCloudFrontOriginAccessIdentityCommand = exports.se_UpdateCachePolicyCommand = exports.se_UntagResourceCommand = exports.se_TestFunctionCommand = exports.se_TagResourceCommand = exports.se_PublishFunctionCommand = exports.se_ListTagsForResourceCommand = exports.se_ListStreamingDistributionsCommand = exports.se_ListResponseHeadersPoliciesCommand = exports.se_ListRealtimeLogConfigsCommand = exports.se_ListPublicKeysCommand = exports.se_ListOriginRequestPoliciesCommand = exports.se_ListOriginAccessControlsCommand = exports.se_ListKeyValueStoresCommand = exports.se_ListKeyGroupsCommand = exports.se_ListInvalidationsCommand = exports.se_ListFunctionsCommand = exports.se_ListFieldLevelEncryptionProfilesCommand = exports.se_ListFieldLevelEncryptionConfigsCommand = exports.se_ListDistributionsByWebACLIdCommand = exports.se_ListDistributionsByResponseHeadersPolicyIdCommand = exports.se_ListDistributionsByRealtimeLogConfigCommand = exports.se_ListDistributionsByOriginRequestPolicyIdCommand = exports.se_ListDistributionsByKeyGroupCommand = exports.se_ListDistributionsByCachePolicyIdCommand = exports.se_ListDistributionsCommand = exports.se_ListContinuousDeploymentPoliciesCommand = exports.se_ListConflictingAliasesCommand = exports.se_ListCloudFrontOriginAccessIdentitiesCommand = exports.se_ListCachePoliciesCommand = exports.se_GetStreamingDistributionConfigCommand = exports.se_GetStreamingDistributionCommand = exports.se_GetResponseHeadersPolicyConfigCommand = exports.se_GetResponseHeadersPolicyCommand = exports.se_GetRealtimeLogConfigCommand = exports.se_GetPublicKeyConfigCommand = exports.se_GetPublicKeyCommand = exports.se_GetOriginRequestPolicyConfigCommand = exports.se_GetOriginRequestPolicyCommand = exports.se_GetOriginAccessControlConfigCommand = exports.se_GetOriginAccessControlCommand = exports.se_GetMonitoringSubscriptionCommand = exports.se_GetKeyGroupConfigCommand = exports.se_GetKeyGroupCommand = exports.se_GetInvalidationCommand = exports.se_GetFunctionCommand = exports.se_GetFieldLevelEncryptionProfileConfigCommand = void 0;
exports.de_DescribeKeyValueStoreCommand = exports.de_DescribeFunctionCommand = exports.de_DeleteStreamingDistributionCommand = exports.de_DeleteResponseHeadersPolicyCommand = exports.de_DeleteRealtimeLogConfigCommand = exports.de_DeletePublicKeyCommand = exports.de_DeleteOriginRequestPolicyCommand = exports.de_DeleteOriginAccessControlCommand = exports.de_DeleteMonitoringSubscriptionCommand = exports.de_DeleteKeyValueStoreCommand = exports.de_DeleteKeyGroupCommand = exports.de_DeleteFunctionCommand = exports.de_DeleteFieldLevelEncryptionProfileCommand = exports.de_DeleteFieldLevelEncryptionConfigCommand = exports.de_DeleteDistributionCommand = exports.de_DeleteContinuousDeploymentPolicyCommand = exports.de_DeleteCloudFrontOriginAccessIdentityCommand = exports.de_DeleteCachePolicyCommand = exports.de_CreateStreamingDistributionWithTagsCommand = exports.de_CreateStreamingDistributionCommand = exports.de_CreateResponseHeadersPolicyCommand = exports.de_CreateRealtimeLogConfigCommand = exports.de_CreatePublicKeyCommand = exports.de_CreateOriginRequestPolicyCommand = exports.de_CreateOriginAccessControlCommand = exports.de_CreateMonitoringSubscriptionCommand = exports.de_CreateKeyValueStoreCommand = exports.de_CreateKeyGroupCommand = exports.de_CreateInvalidationCommand = exports.de_CreateFunctionCommand = exports.de_CreateFieldLevelEncryptionProfileCommand = exports.de_CreateFieldLevelEncryptionConfigCommand = exports.de_CreateDistributionWithTagsCommand = exports.de_CreateDistributionCommand = exports.de_CreateContinuousDeploymentPolicyCommand = exports.de_CreateCloudFrontOriginAccessIdentityCommand = exports.de_CreateCachePolicyCommand = exports.de_CopyDistributionCommand = exports.de_AssociateAliasCommand = exports.se_UpdateStreamingDistributionCommand = exports.se_UpdateResponseHeadersPolicyCommand = exports.se_UpdateRealtimeLogConfigCommand = exports.se_UpdatePublicKeyCommand = exports.se_UpdateOriginRequestPolicyCommand = exports.se_UpdateOriginAccessControlCommand = exports.se_UpdateKeyValueStoreCommand = exports.se_UpdateKeyGroupCommand = exports.se_UpdateFunctionCommand = exports.se_UpdateFieldLevelEncryptionProfileCommand = exports.se_UpdateFieldLevelEncryptionConfigCommand = void 0;
exports.de_ListResponseHeadersPoliciesCommand = exports.de_ListRealtimeLogConfigsCommand = exports.de_ListPublicKeysCommand = exports.de_ListOriginRequestPoliciesCommand = exports.de_ListOriginAccessControlsCommand = exports.de_ListKeyValueStoresCommand = exports.de_ListKeyGroupsCommand = exports.de_ListInvalidationsCommand = exports.de_ListFunctionsCommand = exports.de_ListFieldLevelEncryptionProfilesCommand = exports.de_ListFieldLevelEncryptionConfigsCommand = exports.de_ListDistributionsByWebACLIdCommand = exports.de_ListDistributionsByResponseHeadersPolicyIdCommand = exports.de_ListDistributionsByRealtimeLogConfigCommand = exports.de_ListDistributionsByOriginRequestPolicyIdCommand = exports.de_ListDistributionsByKeyGroupCommand = exports.de_ListDistributionsByCachePolicyIdCommand = exports.de_ListDistributionsCommand = exports.de_ListContinuousDeploymentPoliciesCommand = exports.de_ListConflictingAliasesCommand = exports.de_ListCloudFrontOriginAccessIdentitiesCommand = exports.de_ListCachePoliciesCommand = exports.de_GetStreamingDistributionConfigCommand = exports.de_GetStreamingDistributionCommand = exports.de_GetResponseHeadersPolicyConfigCommand = exports.de_GetResponseHeadersPolicyCommand = exports.de_GetRealtimeLogConfigCommand = exports.de_GetPublicKeyConfigCommand = exports.de_GetPublicKeyCommand = exports.de_GetOriginRequestPolicyConfigCommand = exports.de_GetOriginRequestPolicyCommand = exports.de_GetOriginAccessControlConfigCommand = exports.de_GetOriginAccessControlCommand = exports.de_GetMonitoringSubscriptionCommand = exports.de_GetKeyGroupConfigCommand = exports.de_GetKeyGroupCommand = exports.de_GetInvalidationCommand = exports.de_GetFunctionCommand = exports.de_GetFieldLevelEncryptionProfileConfigCommand = exports.de_GetFieldLevelEncryptionProfileCommand = exports.de_GetFieldLevelEncryptionConfigCommand = exports.de_GetFieldLevelEncryptionCommand = exports.de_GetDistributionConfigCommand = exports.de_GetDistributionCommand = exports.de_GetContinuousDeploymentPolicyConfigCommand = exports.de_GetContinuousDeploymentPolicyCommand = exports.de_GetCloudFrontOriginAccessIdentityConfigCommand = exports.de_GetCloudFrontOriginAccessIdentityCommand = exports.de_GetCachePolicyConfigCommand = exports.de_GetCachePolicyCommand = void 0;
exports.de_UpdateStreamingDistributionCommand = exports.de_UpdateResponseHeadersPolicyCommand = exports.de_UpdateRealtimeLogConfigCommand = exports.de_UpdatePublicKeyCommand = exports.de_UpdateOriginRequestPolicyCommand = exports.de_UpdateOriginAccessControlCommand = exports.de_UpdateKeyValueStoreCommand = exports.de_UpdateKeyGroupCommand = exports.de_UpdateFunctionCommand = exports.de_UpdateFieldLevelEncryptionProfileCommand = exports.de_UpdateFieldLevelEncryptionConfigCommand = exports.de_UpdateDistributionWithStagingConfigCommand = exports.de_UpdateDistributionCommand = exports.de_UpdateContinuousDeploymentPolicyCommand = exports.de_UpdateCloudFrontOriginAccessIdentityCommand = exports.de_UpdateCachePolicyCommand = exports.de_UntagResourceCommand = exports.de_TestFunctionCommand = exports.de_TagResourceCommand = exports.de_PublishFunctionCommand = exports.de_ListTagsForResourceCommand = exports.de_ListStreamingDistributionsCommand = void 0;
const xml_builder_1 = require("@aws-sdk/xml-builder");
const core_1 = require("@smithy/core");
const smithy_client_1 = require("@smithy/smithy-client");
const fast_xml_parser_1 = require("fast-xml-parser");
const CloudFrontServiceException_1 = require("../models/CloudFrontServiceException");
const models_0_1 = require("../models/models_0");
const models_1_1 = require("../models/models_1");
const se_AssociateAliasCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{TargetDistributionId}/associate-alias");
    b.p("TargetDistributionId", () => input.TargetDistributionId, "{TargetDistributionId}", false);
    const query = (0, smithy_client_1.map)({
        [_A]: [, (0, smithy_client_1.expectNonNull)(input[_A], `Alias`)],
    });
    let body;
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_AssociateAliasCommand = se_AssociateAliasCommand;
const se_CopyDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_s]: [() => isSerializableHeaderValue(input[_S]), () => input[_S].toString()],
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/distribution/{PrimaryDistributionId}/copy");
    b.p("PrimaryDistributionId", () => input.PrimaryDistributionId, "{PrimaryDistributionId}", false);
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_CDR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CopyDistributionCommand = se_CopyDistributionCommand;
const se_CreateCachePolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/cache-policy");
    let body;
    let contents;
    if (input.CachePolicyConfig !== undefined) {
        contents = se_CachePolicyConfig(input.CachePolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateCachePolicyCommand = se_CreateCachePolicyCommand;
const se_CreateCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/origin-access-identity/cloudfront");
    let body;
    let contents;
    if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
        contents = se_CloudFrontOriginAccessIdentityConfig(input.CloudFrontOriginAccessIdentityConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateCloudFrontOriginAccessIdentityCommand = se_CreateCloudFrontOriginAccessIdentityCommand;
const se_CreateContinuousDeploymentPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/continuous-deployment-policy");
    let body;
    let contents;
    if (input.ContinuousDeploymentPolicyConfig !== undefined) {
        contents = se_ContinuousDeploymentPolicyConfig(input.ContinuousDeploymentPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateContinuousDeploymentPolicyCommand = se_CreateContinuousDeploymentPolicyCommand;
const se_CreateDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distribution");
    let body;
    let contents;
    if (input.DistributionConfig !== undefined) {
        contents = se_DistributionConfig(input.DistributionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateDistributionCommand = se_CreateDistributionCommand;
const se_CreateDistributionWithTagsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distribution");
    const query = (0, smithy_client_1.map)({
        [_WT]: [, ""],
    });
    let body;
    let contents;
    if (input.DistributionConfigWithTags !== undefined) {
        contents = se_DistributionConfigWithTags(input.DistributionConfigWithTags, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CreateDistributionWithTagsCommand = se_CreateDistributionWithTagsCommand;
const se_CreateFieldLevelEncryptionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/field-level-encryption");
    let body;
    let contents;
    if (input.FieldLevelEncryptionConfig !== undefined) {
        contents = se_FieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateFieldLevelEncryptionConfigCommand = se_CreateFieldLevelEncryptionConfigCommand;
const se_CreateFieldLevelEncryptionProfileCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/field-level-encryption-profile");
    let body;
    let contents;
    if (input.FieldLevelEncryptionProfileConfig !== undefined) {
        contents = se_FieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateFieldLevelEncryptionProfileCommand = se_CreateFieldLevelEncryptionProfileCommand;
const se_CreateFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/function");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_CFR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_FC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FB, context.base64Encoder(input[_FC])).n(_FC));
    }
    if (input[_FCu] != null) {
        bn.c(se_FunctionConfig(input[_FCu], context).n(_FCu));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FN, input[_N]).n(_N));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateFunctionCommand = se_CreateFunctionCommand;
const se_CreateInvalidationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distribution/{DistributionId}/invalidation");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    let contents;
    if (input.InvalidationBatch !== undefined) {
        contents = se_InvalidationBatch(input.InvalidationBatch, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateInvalidationCommand = se_CreateInvalidationCommand;
const se_CreateKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/key-group");
    let body;
    let contents;
    if (input.KeyGroupConfig !== undefined) {
        contents = se_KeyGroupConfig(input.KeyGroupConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateKeyGroupCommand = se_CreateKeyGroupCommand;
const se_CreateKeyValueStoreCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/key-value-store");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_CKVSR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_KVSC, input[_C]).n(_C));
    }
    if (input[_IS] != null) {
        bn.c(se_ImportSource(input[_IS], context).n(_IS));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_KVSN, input[_N]).n(_N));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateKeyValueStoreCommand = se_CreateKeyValueStoreCommand;
const se_CreateMonitoringSubscriptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distributions/{DistributionId}/monitoring-subscription");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    let contents;
    if (input.MonitoringSubscription !== undefined) {
        contents = se_MonitoringSubscription(input.MonitoringSubscription, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateMonitoringSubscriptionCommand = se_CreateMonitoringSubscriptionCommand;
const se_CreateOriginAccessControlCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/origin-access-control");
    let body;
    let contents;
    if (input.OriginAccessControlConfig !== undefined) {
        contents = se_OriginAccessControlConfig(input.OriginAccessControlConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateOriginAccessControlCommand = se_CreateOriginAccessControlCommand;
const se_CreateOriginRequestPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/origin-request-policy");
    let body;
    let contents;
    if (input.OriginRequestPolicyConfig !== undefined) {
        contents = se_OriginRequestPolicyConfig(input.OriginRequestPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateOriginRequestPolicyCommand = se_CreateOriginRequestPolicyCommand;
const se_CreatePublicKeyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/public-key");
    let body;
    let contents;
    if (input.PublicKeyConfig !== undefined) {
        contents = se_PublicKeyConfig(input.PublicKeyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreatePublicKeyCommand = se_CreatePublicKeyCommand;
const se_CreateRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/realtime-log-config");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_CRLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    bn.lc(input, "EndPoints", "EndPoints", () => se_EndPointList(input[_EP], context));
    bn.lc(input, "Fields", "Fields", () => se_FieldList(input[_F], context));
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_SR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_SR])).n(_SR));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateRealtimeLogConfigCommand = se_CreateRealtimeLogConfigCommand;
const se_CreateResponseHeadersPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/response-headers-policy");
    let body;
    let contents;
    if (input.ResponseHeadersPolicyConfig !== undefined) {
        contents = se_ResponseHeadersPolicyConfig(input.ResponseHeadersPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateResponseHeadersPolicyCommand = se_CreateResponseHeadersPolicyCommand;
const se_CreateStreamingDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/streaming-distribution");
    let body;
    let contents;
    if (input.StreamingDistributionConfig !== undefined) {
        contents = se_StreamingDistributionConfig(input.StreamingDistributionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateStreamingDistributionCommand = se_CreateStreamingDistributionCommand;
const se_CreateStreamingDistributionWithTagsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/streaming-distribution");
    const query = (0, smithy_client_1.map)({
        [_WT]: [, ""],
    });
    let body;
    let contents;
    if (input.StreamingDistributionConfigWithTags !== undefined) {
        contents = se_StreamingDistributionConfigWithTags(input.StreamingDistributionConfigWithTags, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CreateStreamingDistributionWithTagsCommand = se_CreateStreamingDistributionWithTagsCommand;
const se_DeleteCachePolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/cache-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteCachePolicyCommand = se_DeleteCachePolicyCommand;
const se_DeleteCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-access-identity/cloudfront/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteCloudFrontOriginAccessIdentityCommand = se_DeleteCloudFrontOriginAccessIdentityCommand;
const se_DeleteContinuousDeploymentPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/continuous-deployment-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteContinuousDeploymentPolicyCommand = se_DeleteContinuousDeploymentPolicyCommand;
const se_DeleteDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/distribution/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteDistributionCommand = se_DeleteDistributionCommand;
const se_DeleteFieldLevelEncryptionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/field-level-encryption/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteFieldLevelEncryptionConfigCommand = se_DeleteFieldLevelEncryptionConfigCommand;
const se_DeleteFieldLevelEncryptionProfileCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/field-level-encryption-profile/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteFieldLevelEncryptionProfileCommand = se_DeleteFieldLevelEncryptionProfileCommand;
const se_DeleteFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/function/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteFunctionCommand = se_DeleteFunctionCommand;
const se_DeleteKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/key-group/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteKeyGroupCommand = se_DeleteKeyGroupCommand;
const se_DeleteKeyValueStoreCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/key-value-store/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteKeyValueStoreCommand = se_DeleteKeyValueStoreCommand;
const se_DeleteMonitoringSubscriptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributions/{DistributionId}/monitoring-subscription");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteMonitoringSubscriptionCommand = se_DeleteMonitoringSubscriptionCommand;
const se_DeleteOriginAccessControlCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-access-control/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteOriginAccessControlCommand = se_DeleteOriginAccessControlCommand;
const se_DeleteOriginRequestPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-request-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteOriginRequestPolicyCommand = se_DeleteOriginRequestPolicyCommand;
const se_DeletePublicKeyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/public-key/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeletePublicKeyCommand = se_DeletePublicKeyCommand;
const se_DeleteRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/delete-realtime-log-config");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_DRLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_ARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ARN]).n(_ARN));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_DeleteRealtimeLogConfigCommand = se_DeleteRealtimeLogConfigCommand;
const se_DeleteResponseHeadersPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/response-headers-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteResponseHeadersPolicyCommand = se_DeleteResponseHeadersPolicyCommand;
const se_DeleteStreamingDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/streaming-distribution/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteStreamingDistributionCommand = se_DeleteStreamingDistributionCommand;
const se_DescribeFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/function/{Name}/describe");
    b.p("Name", () => input.Name, "{Name}", false);
    const query = (0, smithy_client_1.map)({
        [_St]: [, input[_St]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DescribeFunctionCommand = se_DescribeFunctionCommand;
const se_DescribeKeyValueStoreCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-value-store/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_DescribeKeyValueStoreCommand = se_DescribeKeyValueStoreCommand;
const se_GetCachePolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/cache-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetCachePolicyCommand = se_GetCachePolicyCommand;
const se_GetCachePolicyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/cache-policy/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetCachePolicyConfigCommand = se_GetCachePolicyConfigCommand;
const se_GetCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-identity/cloudfront/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetCloudFrontOriginAccessIdentityCommand = se_GetCloudFrontOriginAccessIdentityCommand;
const se_GetCloudFrontOriginAccessIdentityConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-identity/cloudfront/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetCloudFrontOriginAccessIdentityConfigCommand = se_GetCloudFrontOriginAccessIdentityConfigCommand;
const se_GetContinuousDeploymentPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/continuous-deployment-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetContinuousDeploymentPolicyCommand = se_GetContinuousDeploymentPolicyCommand;
const se_GetContinuousDeploymentPolicyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/continuous-deployment-policy/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetContinuousDeploymentPolicyConfigCommand = se_GetContinuousDeploymentPolicyConfigCommand;
const se_GetDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetDistributionCommand = se_GetDistributionCommand;
const se_GetDistributionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetDistributionConfigCommand = se_GetDistributionConfigCommand;
const se_GetFieldLevelEncryptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetFieldLevelEncryptionCommand = se_GetFieldLevelEncryptionCommand;
const se_GetFieldLevelEncryptionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetFieldLevelEncryptionConfigCommand = se_GetFieldLevelEncryptionConfigCommand;
const se_GetFieldLevelEncryptionProfileCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption-profile/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetFieldLevelEncryptionProfileCommand = se_GetFieldLevelEncryptionProfileCommand;
const se_GetFieldLevelEncryptionProfileConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption-profile/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetFieldLevelEncryptionProfileConfigCommand = se_GetFieldLevelEncryptionProfileConfigCommand;
const se_GetFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/function/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    const query = (0, smithy_client_1.map)({
        [_St]: [, input[_St]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetFunctionCommand = se_GetFunctionCommand;
const se_GetInvalidationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{DistributionId}/invalidation/{Id}");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetInvalidationCommand = se_GetInvalidationCommand;
const se_GetKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-group/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetKeyGroupCommand = se_GetKeyGroupCommand;
const se_GetKeyGroupConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-group/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetKeyGroupConfigCommand = se_GetKeyGroupConfigCommand;
const se_GetMonitoringSubscriptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributions/{DistributionId}/monitoring-subscription");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetMonitoringSubscriptionCommand = se_GetMonitoringSubscriptionCommand;
const se_GetOriginAccessControlCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-control/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetOriginAccessControlCommand = se_GetOriginAccessControlCommand;
const se_GetOriginAccessControlConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-control/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetOriginAccessControlConfigCommand = se_GetOriginAccessControlConfigCommand;
const se_GetOriginRequestPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-request-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetOriginRequestPolicyCommand = se_GetOriginRequestPolicyCommand;
const se_GetOriginRequestPolicyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-request-policy/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetOriginRequestPolicyConfigCommand = se_GetOriginRequestPolicyConfigCommand;
const se_GetPublicKeyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/public-key/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetPublicKeyCommand = se_GetPublicKeyCommand;
const se_GetPublicKeyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/public-key/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetPublicKeyConfigCommand = se_GetPublicKeyConfigCommand;
const se_GetRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/get-realtime-log-config");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_GRLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_ARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ARN]).n(_ARN));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_GetRealtimeLogConfigCommand = se_GetRealtimeLogConfigCommand;
const se_GetResponseHeadersPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/response-headers-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetResponseHeadersPolicyCommand = se_GetResponseHeadersPolicyCommand;
const se_GetResponseHeadersPolicyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/response-headers-policy/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetResponseHeadersPolicyConfigCommand = se_GetResponseHeadersPolicyConfigCommand;
const se_GetStreamingDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/streaming-distribution/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetStreamingDistributionCommand = se_GetStreamingDistributionCommand;
const se_GetStreamingDistributionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/streaming-distribution/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetStreamingDistributionConfigCommand = se_GetStreamingDistributionConfigCommand;
const se_ListCachePoliciesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/cache-policy");
    const query = (0, smithy_client_1.map)({
        [_T]: [, input[_T]],
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListCachePoliciesCommand = se_ListCachePoliciesCommand;
const se_ListCloudFrontOriginAccessIdentitiesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-identity/cloudfront");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListCloudFrontOriginAccessIdentitiesCommand = se_ListCloudFrontOriginAccessIdentitiesCommand;
const se_ListConflictingAliasesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/conflicting-alias");
    const query = (0, smithy_client_1.map)({
        [_DI]: [, (0, smithy_client_1.expectNonNull)(input[_DI], `DistributionId`)],
        [_A]: [, (0, smithy_client_1.expectNonNull)(input[_A], `Alias`)],
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListConflictingAliasesCommand = se_ListConflictingAliasesCommand;
const se_ListContinuousDeploymentPoliciesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/continuous-deployment-policy");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListContinuousDeploymentPoliciesCommand = se_ListContinuousDeploymentPoliciesCommand;
const se_ListDistributionsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsCommand = se_ListDistributionsCommand;
const se_ListDistributionsByCachePolicyIdCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByCachePolicyId/{CachePolicyId}");
    b.p("CachePolicyId", () => input.CachePolicyId, "{CachePolicyId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByCachePolicyIdCommand = se_ListDistributionsByCachePolicyIdCommand;
const se_ListDistributionsByKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByKeyGroupId/{KeyGroupId}");
    b.p("KeyGroupId", () => input.KeyGroupId, "{KeyGroupId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByKeyGroupCommand = se_ListDistributionsByKeyGroupCommand;
const se_ListDistributionsByOriginRequestPolicyIdCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByOriginRequestPolicyId/{OriginRequestPolicyId}");
    b.p("OriginRequestPolicyId", () => input.OriginRequestPolicyId, "{OriginRequestPolicyId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByOriginRequestPolicyIdCommand = se_ListDistributionsByOriginRequestPolicyIdCommand;
const se_ListDistributionsByRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distributionsByRealtimeLogConfig");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_LDBRLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_M] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_M]).n(_M));
    }
    if (input[_MI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_I, String(input[_MI])).n(_MI));
    }
    if (input[_RLCA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RLCA]).n(_RLCA));
    }
    if (input[_RLCN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RLCN]).n(_RLCN));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_ListDistributionsByRealtimeLogConfigCommand = se_ListDistributionsByRealtimeLogConfigCommand;
const se_ListDistributionsByResponseHeadersPolicyIdCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByResponseHeadersPolicyId/{ResponseHeadersPolicyId}");
    b.p("ResponseHeadersPolicyId", () => input.ResponseHeadersPolicyId, "{ResponseHeadersPolicyId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByResponseHeadersPolicyIdCommand = se_ListDistributionsByResponseHeadersPolicyIdCommand;
const se_ListDistributionsByWebACLIdCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByWebACLId/{WebACLId}");
    b.p("WebACLId", () => input.WebACLId, "{WebACLId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByWebACLIdCommand = se_ListDistributionsByWebACLIdCommand;
const se_ListFieldLevelEncryptionConfigsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListFieldLevelEncryptionConfigsCommand = se_ListFieldLevelEncryptionConfigsCommand;
const se_ListFieldLevelEncryptionProfilesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption-profile");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListFieldLevelEncryptionProfilesCommand = se_ListFieldLevelEncryptionProfilesCommand;
const se_ListFunctionsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/function");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
        [_St]: [, input[_St]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListFunctionsCommand = se_ListFunctionsCommand;
const se_ListInvalidationsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{DistributionId}/invalidation");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListInvalidationsCommand = se_ListInvalidationsCommand;
const se_ListKeyGroupsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-group");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListKeyGroupsCommand = se_ListKeyGroupsCommand;
const se_ListKeyValueStoresCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-value-store");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
        [_Sta]: [, input[_Sta]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListKeyValueStoresCommand = se_ListKeyValueStoresCommand;
const se_ListOriginAccessControlsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-control");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListOriginAccessControlsCommand = se_ListOriginAccessControlsCommand;
const se_ListOriginRequestPoliciesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-request-policy");
    const query = (0, smithy_client_1.map)({
        [_T]: [, input[_T]],
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListOriginRequestPoliciesCommand = se_ListOriginRequestPoliciesCommand;
const se_ListPublicKeysCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/public-key");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListPublicKeysCommand = se_ListPublicKeysCommand;
const se_ListRealtimeLogConfigsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/realtime-log-config");
    const query = (0, smithy_client_1.map)({
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
        [_M]: [, input[_M]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListRealtimeLogConfigsCommand = se_ListRealtimeLogConfigsCommand;
const se_ListResponseHeadersPoliciesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/response-headers-policy");
    const query = (0, smithy_client_1.map)({
        [_T]: [, input[_T]],
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListResponseHeadersPoliciesCommand = se_ListResponseHeadersPoliciesCommand;
const se_ListStreamingDistributionsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/streaming-distribution");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListStreamingDistributionsCommand = se_ListStreamingDistributionsCommand;
const se_ListTagsForResourceCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/tagging");
    const query = (0, smithy_client_1.map)({
        [_R]: [, (0, smithy_client_1.expectNonNull)(input[_R], `Resource`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListTagsForResourceCommand = se_ListTagsForResourceCommand;
const se_PublishFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/function/{Name}/publish");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_PublishFunctionCommand = se_PublishFunctionCommand;
const se_TagResourceCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/tagging");
    const query = (0, smithy_client_1.map)({
        [_O]: [, "Tag"],
        [_R]: [, (0, smithy_client_1.expectNonNull)(input[_R], `Resource`)],
    });
    let body;
    let contents;
    if (input.Tags !== undefined) {
        contents = se_Tags(input.Tags, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_TestFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/function/{Name}/test");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_TFR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_EO] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FEO, context.base64Encoder(input[_EO])).n(_EO));
    }
    if (input[_St] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FS, input[_St]).n(_St));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_TestFunctionCommand = se_TestFunctionCommand;
const se_UntagResourceCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/tagging");
    const query = (0, smithy_client_1.map)({
        [_O]: [, "Untag"],
        [_R]: [, (0, smithy_client_1.expectNonNull)(input[_R], `Resource`)],
    });
    let body;
    let contents;
    if (input.TagKeys !== undefined) {
        contents = se_TagKeys(input.TagKeys, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateCachePolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/cache-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.CachePolicyConfig !== undefined) {
        contents = se_CachePolicyConfig(input.CachePolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateCachePolicyCommand = se_UpdateCachePolicyCommand;
const se_UpdateCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-access-identity/cloudfront/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
        contents = se_CloudFrontOriginAccessIdentityConfig(input.CloudFrontOriginAccessIdentityConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateCloudFrontOriginAccessIdentityCommand = se_UpdateCloudFrontOriginAccessIdentityCommand;
const se_UpdateContinuousDeploymentPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/continuous-deployment-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.ContinuousDeploymentPolicyConfig !== undefined) {
        contents = se_ContinuousDeploymentPolicyConfig(input.ContinuousDeploymentPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateContinuousDeploymentPolicyCommand = se_UpdateContinuousDeploymentPolicyCommand;
const se_UpdateDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/distribution/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.DistributionConfig !== undefined) {
        contents = se_DistributionConfig(input.DistributionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateDistributionCommand = se_UpdateDistributionCommand;
const se_UpdateDistributionWithStagingConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/distribution/{Id}/promote-staging-config");
    b.p("Id", () => input.Id, "{Id}", false);
    const query = (0, smithy_client_1.map)({
        [_SDI]: [, input[_SDI]],
    });
    let body;
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_UpdateDistributionWithStagingConfigCommand = se_UpdateDistributionWithStagingConfigCommand;
const se_UpdateFieldLevelEncryptionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/field-level-encryption/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.FieldLevelEncryptionConfig !== undefined) {
        contents = se_FieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateFieldLevelEncryptionConfigCommand = se_UpdateFieldLevelEncryptionConfigCommand;
const se_UpdateFieldLevelEncryptionProfileCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/field-level-encryption-profile/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.FieldLevelEncryptionProfileConfig !== undefined) {
        contents = se_FieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateFieldLevelEncryptionProfileCommand = se_UpdateFieldLevelEncryptionProfileCommand;
const se_UpdateFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/function/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_UFR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_FC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FB, context.base64Encoder(input[_FC])).n(_FC));
    }
    if (input[_FCu] != null) {
        bn.c(se_FunctionConfig(input[_FCu], context).n(_FCu));
    }
    body += bn.toString();
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateFunctionCommand = se_UpdateFunctionCommand;
const se_UpdateKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/key-group/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.KeyGroupConfig !== undefined) {
        contents = se_KeyGroupConfig(input.KeyGroupConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateKeyGroupCommand = se_UpdateKeyGroupCommand;
const se_UpdateKeyValueStoreCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/key-value-store/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_UKVSR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_KVSC, input[_C]).n(_C));
    }
    body += bn.toString();
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateKeyValueStoreCommand = se_UpdateKeyValueStoreCommand;
const se_UpdateOriginAccessControlCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-access-control/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.OriginAccessControlConfig !== undefined) {
        contents = se_OriginAccessControlConfig(input.OriginAccessControlConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateOriginAccessControlCommand = se_UpdateOriginAccessControlCommand;
const se_UpdateOriginRequestPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-request-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.OriginRequestPolicyConfig !== undefined) {
        contents = se_OriginRequestPolicyConfig(input.OriginRequestPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateOriginRequestPolicyCommand = se_UpdateOriginRequestPolicyCommand;
const se_UpdatePublicKeyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/public-key/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.PublicKeyConfig !== undefined) {
        contents = se_PublicKeyConfig(input.PublicKeyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdatePublicKeyCommand = se_UpdatePublicKeyCommand;
const se_UpdateRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/realtime-log-config");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_URLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_ARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ARN]).n(_ARN));
    }
    bn.lc(input, "EndPoints", "EndPoints", () => se_EndPointList(input[_EP], context));
    bn.lc(input, "Fields", "Fields", () => se_FieldList(input[_F], context));
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_SR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_SR])).n(_SR));
    }
    body += bn.toString();
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateRealtimeLogConfigCommand = se_UpdateRealtimeLogConfigCommand;
const se_UpdateResponseHeadersPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/response-headers-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.ResponseHeadersPolicyConfig !== undefined) {
        contents = se_ResponseHeadersPolicyConfig(input.ResponseHeadersPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateResponseHeadersPolicyCommand = se_UpdateResponseHeadersPolicyCommand;
const se_UpdateStreamingDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/streaming-distribution/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.StreamingDistributionConfig !== undefined) {
        contents = se_StreamingDistributionConfig(input.StreamingDistributionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateStreamingDistributionCommand = se_UpdateStreamingDistributionCommand;
const de_AssociateAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AssociateAliasCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AssociateAliasCommand = de_AssociateAliasCommand;
const de_AssociateAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CopyDistributionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CopyDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_CopyDistributionCommand = de_CopyDistributionCommand;
const de_CopyDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "DistributionAlreadyExists":
        case "com.amazonaws.cloudfront#DistributionAlreadyExists":
            throw await de_DistributionAlreadyExistsRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidProtocolSettings":
        case "com.amazonaws.cloudfront#InvalidProtocolSettings":
            throw await de_InvalidProtocolSettingsRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributions":
        case "com.amazonaws.cloudfront#TooManyDistributions":
            throw await de_TooManyDistributionsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateCachePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicy = de_CachePolicy(data, context);
    return contents;
};
exports.de_CreateCachePolicyCommand = de_CreateCachePolicyCommand;
const de_CreateCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CachePolicyAlreadyExists":
        case "com.amazonaws.cloudfront#CachePolicyAlreadyExists":
            throw await de_CachePolicyAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "TooManyCachePolicies":
        case "com.amazonaws.cloudfront#TooManyCachePolicies":
            throw await de_TooManyCachePoliciesRes(parsedOutput, context);
        case "TooManyCookiesInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInCachePolicy":
            throw await de_TooManyCookiesInCachePolicyRes(parsedOutput, context);
        case "TooManyHeadersInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInCachePolicy":
            throw await de_TooManyHeadersInCachePolicyRes(parsedOutput, context);
        case "TooManyQueryStringsInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInCachePolicy":
            throw await de_TooManyQueryStringsInCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentity = de_CloudFrontOriginAccessIdentity(data, context);
    return contents;
};
exports.de_CreateCloudFrontOriginAccessIdentityCommand = de_CreateCloudFrontOriginAccessIdentityCommand;
const de_CreateCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudFrontOriginAccessIdentityAlreadyExists":
        case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityAlreadyExists":
            throw await de_CloudFrontOriginAccessIdentityAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "TooManyCloudFrontOriginAccessIdentities":
        case "com.amazonaws.cloudfront#TooManyCloudFrontOriginAccessIdentities":
            throw await de_TooManyCloudFrontOriginAccessIdentitiesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicy = de_ContinuousDeploymentPolicy(data, context);
    return contents;
};
exports.de_CreateContinuousDeploymentPolicyCommand = de_CreateContinuousDeploymentPolicyCommand;
const de_CreateContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyAlreadyExists":
            throw await de_ContinuousDeploymentPolicyAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "StagingDistributionInUse":
        case "com.amazonaws.cloudfront#StagingDistributionInUse":
            throw await de_StagingDistributionInUseRes(parsedOutput, context);
        case "TooManyContinuousDeploymentPolicies":
        case "com.amazonaws.cloudfront#TooManyContinuousDeploymentPolicies":
            throw await de_TooManyContinuousDeploymentPoliciesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateDistributionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_CreateDistributionCommand = de_CreateDistributionCommand;
const de_CreateDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyInUse":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyInUse":
            throw await de_ContinuousDeploymentPolicyInUseRes(parsedOutput, context);
        case "DistributionAlreadyExists":
        case "com.amazonaws.cloudfront#DistributionAlreadyExists":
            throw await de_DistributionAlreadyExistsRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "IllegalOriginAccessConfiguration":
        case "com.amazonaws.cloudfront#IllegalOriginAccessConfiguration":
            throw await de_IllegalOriginAccessConfigurationRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidDomainNameForOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidDomainNameForOriginAccessControl":
            throw await de_InvalidDomainNameForOriginAccessControlRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidProtocolSettings":
        case "com.amazonaws.cloudfront#InvalidProtocolSettings":
            throw await de_InvalidProtocolSettingsRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributions":
        case "com.amazonaws.cloudfront#TooManyDistributions":
            throw await de_TooManyDistributionsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateDistributionWithTagsCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDistributionWithTagsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_CreateDistributionWithTagsCommand = de_CreateDistributionWithTagsCommand;
const de_CreateDistributionWithTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyInUse":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyInUse":
            throw await de_ContinuousDeploymentPolicyInUseRes(parsedOutput, context);
        case "DistributionAlreadyExists":
        case "com.amazonaws.cloudfront#DistributionAlreadyExists":
            throw await de_DistributionAlreadyExistsRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "IllegalOriginAccessConfiguration":
        case "com.amazonaws.cloudfront#IllegalOriginAccessConfiguration":
            throw await de_IllegalOriginAccessConfigurationRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidDomainNameForOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidDomainNameForOriginAccessControl":
            throw await de_InvalidDomainNameForOriginAccessControlRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidProtocolSettings":
        case "com.amazonaws.cloudfront#InvalidProtocolSettings":
            throw await de_InvalidProtocolSettingsRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributions":
        case "com.amazonaws.cloudfront#TooManyDistributions":
            throw await de_TooManyDistributionsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryption = de_FieldLevelEncryption(data, context);
    return contents;
};
exports.de_CreateFieldLevelEncryptionConfigCommand = de_CreateFieldLevelEncryptionConfigCommand;
const de_CreateFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FieldLevelEncryptionConfigAlreadyExists":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigAlreadyExists":
            throw await de_FieldLevelEncryptionConfigAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        case "QueryArgProfileEmpty":
        case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
            throw await de_QueryArgProfileEmptyRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionConfigs":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionConfigs":
            throw await de_TooManyFieldLevelEncryptionConfigsRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionContentTypeProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
            throw await de_TooManyFieldLevelEncryptionContentTypeProfilesRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionQueryArgProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
            throw await de_TooManyFieldLevelEncryptionQueryArgProfilesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfile = de_FieldLevelEncryptionProfile(data, context);
    return contents;
};
exports.de_CreateFieldLevelEncryptionProfileCommand = de_CreateFieldLevelEncryptionProfileCommand;
const de_CreateFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FieldLevelEncryptionProfileAlreadyExists":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
            throw await de_FieldLevelEncryptionProfileAlreadyExistsRes(parsedOutput, context);
        case "FieldLevelEncryptionProfileSizeExceeded":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
            throw await de_FieldLevelEncryptionProfileSizeExceededRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionEncryptionEntities":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
            throw await de_TooManyFieldLevelEncryptionEncryptionEntitiesRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionFieldPatterns":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
            throw await de_TooManyFieldLevelEncryptionFieldPatternsRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionProfiles":
            throw await de_TooManyFieldLevelEncryptionProfilesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateFunctionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = de_FunctionSummary(data, context);
    return contents;
};
exports.de_CreateFunctionCommand = de_CreateFunctionCommand;
const de_CreateFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FunctionAlreadyExists":
        case "com.amazonaws.cloudfront#FunctionAlreadyExists":
            throw await de_FunctionAlreadyExistsRes(parsedOutput, context);
        case "FunctionSizeLimitExceeded":
        case "com.amazonaws.cloudfront#FunctionSizeLimitExceeded":
            throw await de_FunctionSizeLimitExceededRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "TooManyFunctions":
        case "com.amazonaws.cloudfront#TooManyFunctions":
            throw await de_TooManyFunctionsRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateInvalidationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateInvalidationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Invalidation = de_Invalidation(data, context);
    return contents;
};
exports.de_CreateInvalidationCommand = de_CreateInvalidationCommand;
const de_CreateInvalidationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "BatchTooLarge":
        case "com.amazonaws.cloudfront#BatchTooLarge":
            throw await de_BatchTooLargeRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "TooManyInvalidationsInProgress":
        case "com.amazonaws.cloudfront#TooManyInvalidationsInProgress":
            throw await de_TooManyInvalidationsInProgressRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroup = de_KeyGroup(data, context);
    return contents;
};
exports.de_CreateKeyGroupCommand = de_CreateKeyGroupCommand;
const de_CreateKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "KeyGroupAlreadyExists":
        case "com.amazonaws.cloudfront#KeyGroupAlreadyExists":
            throw await de_KeyGroupAlreadyExistsRes(parsedOutput, context);
        case "TooManyKeyGroups":
        case "com.amazonaws.cloudfront#TooManyKeyGroups":
            throw await de_TooManyKeyGroupsRes(parsedOutput, context);
        case "TooManyPublicKeysInKeyGroup":
        case "com.amazonaws.cloudfront#TooManyPublicKeysInKeyGroup":
            throw await de_TooManyPublicKeysInKeyGroupRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateKeyValueStoreCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateKeyValueStoreCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
        [_L]: [, output.headers[_lo]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyValueStore = de_KeyValueStore(data, context);
    return contents;
};
exports.de_CreateKeyValueStoreCommand = de_CreateKeyValueStoreCommand;
const de_CreateKeyValueStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.cloudfront#EntityAlreadyExists":
            throw await de_EntityAlreadyExistsRes(parsedOutput, context);
        case "EntityLimitExceeded":
        case "com.amazonaws.cloudfront#EntityLimitExceeded":
            throw await de_EntityLimitExceededRes(parsedOutput, context);
        case "EntitySizeLimitExceeded":
        case "com.amazonaws.cloudfront#EntitySizeLimitExceeded":
            throw await de_EntitySizeLimitExceededRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateMonitoringSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateMonitoringSubscriptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.MonitoringSubscription = de_MonitoringSubscription(data, context);
    return contents;
};
exports.de_CreateMonitoringSubscriptionCommand = de_CreateMonitoringSubscriptionCommand;
const de_CreateMonitoringSubscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "MonitoringSubscriptionAlreadyExists":
        case "com.amazonaws.cloudfront#MonitoringSubscriptionAlreadyExists":
            throw await de_MonitoringSubscriptionAlreadyExistsRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateOriginAccessControlCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControl = de_OriginAccessControl(data, context);
    return contents;
};
exports.de_CreateOriginAccessControlCommand = de_CreateOriginAccessControlCommand;
const de_CreateOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "OriginAccessControlAlreadyExists":
        case "com.amazonaws.cloudfront#OriginAccessControlAlreadyExists":
            throw await de_OriginAccessControlAlreadyExistsRes(parsedOutput, context);
        case "TooManyOriginAccessControls":
        case "com.amazonaws.cloudfront#TooManyOriginAccessControls":
            throw await de_TooManyOriginAccessControlsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateOriginRequestPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicy = de_OriginRequestPolicy(data, context);
    return contents;
};
exports.de_CreateOriginRequestPolicyCommand = de_CreateOriginRequestPolicyCommand;
const de_CreateOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "OriginRequestPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#OriginRequestPolicyAlreadyExists":
            throw await de_OriginRequestPolicyAlreadyExistsRes(parsedOutput, context);
        case "TooManyCookiesInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInOriginRequestPolicy":
            throw await de_TooManyCookiesInOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyHeadersInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInOriginRequestPolicy":
            throw await de_TooManyHeadersInOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyOriginRequestPolicies":
        case "com.amazonaws.cloudfront#TooManyOriginRequestPolicies":
            throw await de_TooManyOriginRequestPoliciesRes(parsedOutput, context);
        case "TooManyQueryStringsInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInOriginRequestPolicy":
            throw await de_TooManyQueryStringsInOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreatePublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreatePublicKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKey = de_PublicKey(data, context);
    return contents;
};
exports.de_CreatePublicKeyCommand = de_CreatePublicKeyCommand;
const de_CreatePublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "PublicKeyAlreadyExists":
        case "com.amazonaws.cloudfront#PublicKeyAlreadyExists":
            throw await de_PublicKeyAlreadyExistsRes(parsedOutput, context);
        case "TooManyPublicKeys":
        case "com.amazonaws.cloudfront#TooManyPublicKeys":
            throw await de_TooManyPublicKeysRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_RLC] != null) {
        contents[_RLC] = de_RealtimeLogConfig(data[_RLC], context);
    }
    return contents;
};
exports.de_CreateRealtimeLogConfigCommand = de_CreateRealtimeLogConfigCommand;
const de_CreateRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "RealtimeLogConfigAlreadyExists":
        case "com.amazonaws.cloudfront#RealtimeLogConfigAlreadyExists":
            throw await de_RealtimeLogConfigAlreadyExistsRes(parsedOutput, context);
        case "TooManyRealtimeLogConfigs":
        case "com.amazonaws.cloudfront#TooManyRealtimeLogConfigs":
            throw await de_TooManyRealtimeLogConfigsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateResponseHeadersPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicy = de_ResponseHeadersPolicy(data, context);
    return contents;
};
exports.de_CreateResponseHeadersPolicyCommand = de_CreateResponseHeadersPolicyCommand;
const de_CreateResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "ResponseHeadersPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#ResponseHeadersPolicyAlreadyExists":
            throw await de_ResponseHeadersPolicyAlreadyExistsRes(parsedOutput, context);
        case "TooLongCSPInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooLongCSPInResponseHeadersPolicy":
            throw await de_TooLongCSPInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyCustomHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyCustomHeadersInResponseHeadersPolicy":
            throw await de_TooManyCustomHeadersInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyRemoveHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyRemoveHeadersInResponseHeadersPolicy":
            throw await de_TooManyRemoveHeadersInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyResponseHeadersPolicies":
        case "com.amazonaws.cloudfront#TooManyResponseHeadersPolicies":
            throw await de_TooManyResponseHeadersPoliciesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateStreamingDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = de_StreamingDistribution(data, context);
    return contents;
};
exports.de_CreateStreamingDistributionCommand = de_CreateStreamingDistributionCommand;
const de_CreateStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "StreamingDistributionAlreadyExists":
        case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
            throw await de_StreamingDistributionAlreadyExistsRes(parsedOutput, context);
        case "TooManyStreamingDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
            throw await de_TooManyStreamingDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyStreamingDistributions":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
            throw await de_TooManyStreamingDistributionsRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateStreamingDistributionWithTagsCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateStreamingDistributionWithTagsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = de_StreamingDistribution(data, context);
    return contents;
};
exports.de_CreateStreamingDistributionWithTagsCommand = de_CreateStreamingDistributionWithTagsCommand;
const de_CreateStreamingDistributionWithTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "StreamingDistributionAlreadyExists":
        case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
            throw await de_StreamingDistributionAlreadyExistsRes(parsedOutput, context);
        case "TooManyStreamingDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
            throw await de_TooManyStreamingDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyStreamingDistributions":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
            throw await de_TooManyStreamingDistributionsRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteCachePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteCachePolicyCommand = de_DeleteCachePolicyCommand;
const de_DeleteCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CachePolicyInUse":
        case "com.amazonaws.cloudfront#CachePolicyInUse":
            throw await de_CachePolicyInUseRes(parsedOutput, context);
        case "IllegalDelete":
        case "com.amazonaws.cloudfront#IllegalDelete":
            throw await de_IllegalDeleteRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteCloudFrontOriginAccessIdentityCommand = de_DeleteCloudFrontOriginAccessIdentityCommand;
const de_DeleteCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CloudFrontOriginAccessIdentityInUse":
        case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityInUse":
            throw await de_CloudFrontOriginAccessIdentityInUseRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await de_NoSuchCloudFrontOriginAccessIdentityRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteContinuousDeploymentPolicyCommand = de_DeleteContinuousDeploymentPolicyCommand;
const de_DeleteContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyInUse":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyInUse":
            throw await de_ContinuousDeploymentPolicyInUseRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteDistributionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDistributionCommand = de_DeleteDistributionCommand;
const de_DeleteDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "DistributionNotDisabled":
        case "com.amazonaws.cloudfront#DistributionNotDisabled":
            throw await de_DistributionNotDisabledRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteFieldLevelEncryptionConfigCommand = de_DeleteFieldLevelEncryptionConfigCommand;
const de_DeleteFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "FieldLevelEncryptionConfigInUse":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigInUse":
            throw await de_FieldLevelEncryptionConfigInUseRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteFieldLevelEncryptionProfileCommand = de_DeleteFieldLevelEncryptionProfileCommand;
const de_DeleteFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "FieldLevelEncryptionProfileInUse":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileInUse":
            throw await de_FieldLevelEncryptionProfileInUseRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteFunctionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteFunctionCommand = de_DeleteFunctionCommand;
const de_DeleteFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FunctionInUse":
        case "com.amazonaws.cloudfront#FunctionInUse":
            throw await de_FunctionInUseRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteKeyGroupCommand = de_DeleteKeyGroupCommand;
const de_DeleteKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.cloudfront#ResourceInUse":
            throw await de_ResourceInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteKeyValueStoreCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteKeyValueStoreCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteKeyValueStoreCommand = de_DeleteKeyValueStoreCommand;
const de_DeleteKeyValueStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CannotDeleteEntityWhileInUse":
        case "com.amazonaws.cloudfront#CannotDeleteEntityWhileInUse":
            throw await de_CannotDeleteEntityWhileInUseRes(parsedOutput, context);
        case "EntityNotFound":
        case "com.amazonaws.cloudfront#EntityNotFound":
            throw await de_EntityNotFoundRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteMonitoringSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteMonitoringSubscriptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteMonitoringSubscriptionCommand = de_DeleteMonitoringSubscriptionCommand;
const de_DeleteMonitoringSubscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchMonitoringSubscription":
        case "com.amazonaws.cloudfront#NoSuchMonitoringSubscription":
            throw await de_NoSuchMonitoringSubscriptionRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteOriginAccessControlCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteOriginAccessControlCommand = de_DeleteOriginAccessControlCommand;
const de_DeleteOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await de_NoSuchOriginAccessControlRes(parsedOutput, context);
        case "OriginAccessControlInUse":
        case "com.amazonaws.cloudfront#OriginAccessControlInUse":
            throw await de_OriginAccessControlInUseRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteOriginRequestPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteOriginRequestPolicyCommand = de_DeleteOriginRequestPolicyCommand;
const de_DeleteOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalDelete":
        case "com.amazonaws.cloudfront#IllegalDelete":
            throw await de_IllegalDeleteRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "OriginRequestPolicyInUse":
        case "com.amazonaws.cloudfront#OriginRequestPolicyInUse":
            throw await de_OriginRequestPolicyInUseRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeletePublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeletePublicKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeletePublicKeyCommand = de_DeletePublicKeyCommand;
const de_DeletePublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "PublicKeyInUse":
        case "com.amazonaws.cloudfront#PublicKeyInUse":
            throw await de_PublicKeyInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRealtimeLogConfigCommand = de_DeleteRealtimeLogConfigCommand;
const de_DeleteRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "RealtimeLogConfigInUse":
        case "com.amazonaws.cloudfront#RealtimeLogConfigInUse":
            throw await de_RealtimeLogConfigInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteResponseHeadersPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteResponseHeadersPolicyCommand = de_DeleteResponseHeadersPolicyCommand;
const de_DeleteResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalDelete":
        case "com.amazonaws.cloudfront#IllegalDelete":
            throw await de_IllegalDeleteRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "ResponseHeadersPolicyInUse":
        case "com.amazonaws.cloudfront#ResponseHeadersPolicyInUse":
            throw await de_ResponseHeadersPolicyInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteStreamingDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteStreamingDistributionCommand = de_DeleteStreamingDistributionCommand;
const de_DeleteStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await de_NoSuchStreamingDistributionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "StreamingDistributionNotDisabled":
        case "com.amazonaws.cloudfront#StreamingDistributionNotDisabled":
            throw await de_StreamingDistributionNotDisabledRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = de_FunctionSummary(data, context);
    return contents;
};
exports.de_DescribeFunctionCommand = de_DescribeFunctionCommand;
const de_DescribeFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeKeyValueStoreCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeKeyValueStoreCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyValueStore = de_KeyValueStore(data, context);
    return contents;
};
exports.de_DescribeKeyValueStoreCommand = de_DescribeKeyValueStoreCommand;
const de_DescribeKeyValueStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "EntityNotFound":
        case "com.amazonaws.cloudfront#EntityNotFound":
            throw await de_EntityNotFoundRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCachePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicy = de_CachePolicy(data, context);
    return contents;
};
exports.de_GetCachePolicyCommand = de_GetCachePolicyCommand;
const de_GetCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetCachePolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCachePolicyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicyConfig = de_CachePolicyConfig(data, context);
    return contents;
};
exports.de_GetCachePolicyConfigCommand = de_GetCachePolicyConfigCommand;
const de_GetCachePolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentity = de_CloudFrontOriginAccessIdentity(data, context);
    return contents;
};
exports.de_GetCloudFrontOriginAccessIdentityCommand = de_GetCloudFrontOriginAccessIdentityCommand;
const de_GetCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await de_NoSuchCloudFrontOriginAccessIdentityRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetCloudFrontOriginAccessIdentityConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCloudFrontOriginAccessIdentityConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentityConfig = de_CloudFrontOriginAccessIdentityConfig(data, context);
    return contents;
};
exports.de_GetCloudFrontOriginAccessIdentityConfigCommand = de_GetCloudFrontOriginAccessIdentityConfigCommand;
const de_GetCloudFrontOriginAccessIdentityConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await de_NoSuchCloudFrontOriginAccessIdentityRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicy = de_ContinuousDeploymentPolicy(data, context);
    return contents;
};
exports.de_GetContinuousDeploymentPolicyCommand = de_GetContinuousDeploymentPolicyCommand;
const de_GetContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetContinuousDeploymentPolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetContinuousDeploymentPolicyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicyConfig = de_ContinuousDeploymentPolicyConfig(data, context);
    return contents;
};
exports.de_GetContinuousDeploymentPolicyConfigCommand = de_GetContinuousDeploymentPolicyConfigCommand;
const de_GetContinuousDeploymentPolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_GetDistributionCommand = de_GetDistributionCommand;
const de_GetDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetDistributionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDistributionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionConfig = de_DistributionConfig(data, context);
    return contents;
};
exports.de_GetDistributionConfigCommand = de_GetDistributionConfigCommand;
const de_GetDistributionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFieldLevelEncryptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFieldLevelEncryptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryption = de_FieldLevelEncryption(data, context);
    return contents;
};
exports.de_GetFieldLevelEncryptionCommand = de_GetFieldLevelEncryptionCommand;
const de_GetFieldLevelEncryptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionConfig = de_FieldLevelEncryptionConfig(data, context);
    return contents;
};
exports.de_GetFieldLevelEncryptionConfigCommand = de_GetFieldLevelEncryptionConfigCommand;
const de_GetFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfile = de_FieldLevelEncryptionProfile(data, context);
    return contents;
};
exports.de_GetFieldLevelEncryptionProfileCommand = de_GetFieldLevelEncryptionProfileCommand;
const de_GetFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFieldLevelEncryptionProfileConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFieldLevelEncryptionProfileConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfileConfig = de_FieldLevelEncryptionProfileConfig(data, context);
    return contents;
};
exports.de_GetFieldLevelEncryptionProfileConfigCommand = de_GetFieldLevelEncryptionProfileConfigCommand;
const de_GetFieldLevelEncryptionProfileConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
        [_CT]: [, output.headers[_ct]],
    });
    const data = await (0, smithy_client_1.collectBody)(output.body, context);
    contents.FunctionCode = data;
    return contents;
};
exports.de_GetFunctionCommand = de_GetFunctionCommand;
const de_GetFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetInvalidationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetInvalidationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Invalidation = de_Invalidation(data, context);
    return contents;
};
exports.de_GetInvalidationCommand = de_GetInvalidationCommand;
const de_GetInvalidationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchInvalidation":
        case "com.amazonaws.cloudfront#NoSuchInvalidation":
            throw await de_NoSuchInvalidationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroup = de_KeyGroup(data, context);
    return contents;
};
exports.de_GetKeyGroupCommand = de_GetKeyGroupCommand;
const de_GetKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetKeyGroupConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetKeyGroupConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroupConfig = de_KeyGroupConfig(data, context);
    return contents;
};
exports.de_GetKeyGroupConfigCommand = de_GetKeyGroupConfigCommand;
const de_GetKeyGroupConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetMonitoringSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMonitoringSubscriptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.MonitoringSubscription = de_MonitoringSubscription(data, context);
    return contents;
};
exports.de_GetMonitoringSubscriptionCommand = de_GetMonitoringSubscriptionCommand;
const de_GetMonitoringSubscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchMonitoringSubscription":
        case "com.amazonaws.cloudfront#NoSuchMonitoringSubscription":
            throw await de_NoSuchMonitoringSubscriptionRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOriginAccessControlCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControl = de_OriginAccessControl(data, context);
    return contents;
};
exports.de_GetOriginAccessControlCommand = de_GetOriginAccessControlCommand;
const de_GetOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await de_NoSuchOriginAccessControlRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOriginAccessControlConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOriginAccessControlConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControlConfig = de_OriginAccessControlConfig(data, context);
    return contents;
};
exports.de_GetOriginAccessControlConfigCommand = de_GetOriginAccessControlConfigCommand;
const de_GetOriginAccessControlConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await de_NoSuchOriginAccessControlRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOriginRequestPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicy = de_OriginRequestPolicy(data, context);
    return contents;
};
exports.de_GetOriginRequestPolicyCommand = de_GetOriginRequestPolicyCommand;
const de_GetOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOriginRequestPolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOriginRequestPolicyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicyConfig = de_OriginRequestPolicyConfig(data, context);
    return contents;
};
exports.de_GetOriginRequestPolicyConfigCommand = de_GetOriginRequestPolicyConfigCommand;
const de_GetOriginRequestPolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetPublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPublicKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKey = de_PublicKey(data, context);
    return contents;
};
exports.de_GetPublicKeyCommand = de_GetPublicKeyCommand;
const de_GetPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetPublicKeyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPublicKeyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKeyConfig = de_PublicKeyConfig(data, context);
    return contents;
};
exports.de_GetPublicKeyConfigCommand = de_GetPublicKeyConfigCommand;
const de_GetPublicKeyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_RLC] != null) {
        contents[_RLC] = de_RealtimeLogConfig(data[_RLC], context);
    }
    return contents;
};
exports.de_GetRealtimeLogConfigCommand = de_GetRealtimeLogConfigCommand;
const de_GetRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetResponseHeadersPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicy = de_ResponseHeadersPolicy(data, context);
    return contents;
};
exports.de_GetResponseHeadersPolicyCommand = de_GetResponseHeadersPolicyCommand;
const de_GetResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetResponseHeadersPolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetResponseHeadersPolicyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicyConfig = de_ResponseHeadersPolicyConfig(data, context);
    return contents;
};
exports.de_GetResponseHeadersPolicyConfigCommand = de_GetResponseHeadersPolicyConfigCommand;
const de_GetResponseHeadersPolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStreamingDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = de_StreamingDistribution(data, context);
    return contents;
};
exports.de_GetStreamingDistributionCommand = de_GetStreamingDistributionCommand;
const de_GetStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await de_NoSuchStreamingDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetStreamingDistributionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStreamingDistributionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistributionConfig = de_StreamingDistributionConfig(data, context);
    return contents;
};
exports.de_GetStreamingDistributionConfigCommand = de_GetStreamingDistributionConfigCommand;
const de_GetStreamingDistributionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await de_NoSuchStreamingDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListCachePoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCachePoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicyList = de_CachePolicyList(data, context);
    return contents;
};
exports.de_ListCachePoliciesCommand = de_ListCachePoliciesCommand;
const de_ListCachePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListCloudFrontOriginAccessIdentitiesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCloudFrontOriginAccessIdentitiesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentityList = de_CloudFrontOriginAccessIdentityList(data, context);
    return contents;
};
exports.de_ListCloudFrontOriginAccessIdentitiesCommand = de_ListCloudFrontOriginAccessIdentitiesCommand;
const de_ListCloudFrontOriginAccessIdentitiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListConflictingAliasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListConflictingAliasesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ConflictingAliasesList = de_ConflictingAliasesList(data, context);
    return contents;
};
exports.de_ListConflictingAliasesCommand = de_ListConflictingAliasesCommand;
const de_ListConflictingAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListContinuousDeploymentPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListContinuousDeploymentPoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicyList = de_ContinuousDeploymentPolicyList(data, context);
    return contents;
};
exports.de_ListContinuousDeploymentPoliciesCommand = de_ListContinuousDeploymentPoliciesCommand;
const de_ListContinuousDeploymentPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionList = de_DistributionList(data, context);
    return contents;
};
exports.de_ListDistributionsCommand = de_ListDistributionsCommand;
const de_ListDistributionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByCachePolicyIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByCachePolicyIdCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = de_DistributionIdList(data, context);
    return contents;
};
exports.de_ListDistributionsByCachePolicyIdCommand = de_ListDistributionsByCachePolicyIdCommand;
const de_ListDistributionsByCachePolicyIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = de_DistributionIdList(data, context);
    return contents;
};
exports.de_ListDistributionsByKeyGroupCommand = de_ListDistributionsByKeyGroupCommand;
const de_ListDistributionsByKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByOriginRequestPolicyIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByOriginRequestPolicyIdCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = de_DistributionIdList(data, context);
    return contents;
};
exports.de_ListDistributionsByOriginRequestPolicyIdCommand = de_ListDistributionsByOriginRequestPolicyIdCommand;
const de_ListDistributionsByOriginRequestPolicyIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionList = de_DistributionList(data, context);
    return contents;
};
exports.de_ListDistributionsByRealtimeLogConfigCommand = de_ListDistributionsByRealtimeLogConfigCommand;
const de_ListDistributionsByRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByResponseHeadersPolicyIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByResponseHeadersPolicyIdCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = de_DistributionIdList(data, context);
    return contents;
};
exports.de_ListDistributionsByResponseHeadersPolicyIdCommand = de_ListDistributionsByResponseHeadersPolicyIdCommand;
const de_ListDistributionsByResponseHeadersPolicyIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByWebACLIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByWebACLIdCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionList = de_DistributionList(data, context);
    return contents;
};
exports.de_ListDistributionsByWebACLIdCommand = de_ListDistributionsByWebACLIdCommand;
const de_ListDistributionsByWebACLIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListFieldLevelEncryptionConfigsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListFieldLevelEncryptionConfigsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionList = de_FieldLevelEncryptionList(data, context);
    return contents;
};
exports.de_ListFieldLevelEncryptionConfigsCommand = de_ListFieldLevelEncryptionConfigsCommand;
const de_ListFieldLevelEncryptionConfigsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListFieldLevelEncryptionProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListFieldLevelEncryptionProfilesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfileList = de_FieldLevelEncryptionProfileList(data, context);
    return contents;
};
exports.de_ListFieldLevelEncryptionProfilesCommand = de_ListFieldLevelEncryptionProfilesCommand;
const de_ListFieldLevelEncryptionProfilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListFunctionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListFunctionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionList = de_FunctionList(data, context);
    return contents;
};
exports.de_ListFunctionsCommand = de_ListFunctionsCommand;
const de_ListFunctionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListInvalidationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListInvalidationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.InvalidationList = de_InvalidationList(data, context);
    return contents;
};
exports.de_ListInvalidationsCommand = de_ListInvalidationsCommand;
const de_ListInvalidationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListKeyGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListKeyGroupsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroupList = de_KeyGroupList(data, context);
    return contents;
};
exports.de_ListKeyGroupsCommand = de_ListKeyGroupsCommand;
const de_ListKeyGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListKeyValueStoresCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListKeyValueStoresCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyValueStoreList = de_KeyValueStoreList(data, context);
    return contents;
};
exports.de_ListKeyValueStoresCommand = de_ListKeyValueStoresCommand;
const de_ListKeyValueStoresCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListOriginAccessControlsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListOriginAccessControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControlList = de_OriginAccessControlList(data, context);
    return contents;
};
exports.de_ListOriginAccessControlsCommand = de_ListOriginAccessControlsCommand;
const de_ListOriginAccessControlsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListOriginRequestPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListOriginRequestPoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicyList = de_OriginRequestPolicyList(data, context);
    return contents;
};
exports.de_ListOriginRequestPoliciesCommand = de_ListOriginRequestPoliciesCommand;
const de_ListOriginRequestPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListPublicKeysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPublicKeysCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKeyList = de_PublicKeyList(data, context);
    return contents;
};
exports.de_ListPublicKeysCommand = de_ListPublicKeysCommand;
const de_ListPublicKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListRealtimeLogConfigsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListRealtimeLogConfigsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.RealtimeLogConfigs = de_RealtimeLogConfigs(data, context);
    return contents;
};
exports.de_ListRealtimeLogConfigsCommand = de_ListRealtimeLogConfigsCommand;
const de_ListRealtimeLogConfigsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListResponseHeadersPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListResponseHeadersPoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicyList = de_ResponseHeadersPolicyList(data, context);
    return contents;
};
exports.de_ListResponseHeadersPoliciesCommand = de_ListResponseHeadersPoliciesCommand;
const de_ListResponseHeadersPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListStreamingDistributionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListStreamingDistributionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistributionList = de_StreamingDistributionList(data, context);
    return contents;
};
exports.de_ListStreamingDistributionsCommand = de_ListStreamingDistributionsCommand;
const de_ListStreamingDistributionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Tags = de_Tags(data, context);
    return contents;
};
exports.de_ListTagsForResourceCommand = de_ListTagsForResourceCommand;
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PublishFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PublishFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = de_FunctionSummary(data, context);
    return contents;
};
exports.de_PublishFunctionCommand = de_PublishFunctionCommand;
const de_PublishFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TestFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.TestResult = de_TestResult(data, context);
    return contents;
};
exports.de_TestFunctionCommand = de_TestFunctionCommand;
const de_TestFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "TestFunctionFailed":
        case "com.amazonaws.cloudfront#TestFunctionFailed":
            throw await de_TestFunctionFailedRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCachePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicy = de_CachePolicy(data, context);
    return contents;
};
exports.de_UpdateCachePolicyCommand = de_UpdateCachePolicyCommand;
const de_UpdateCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CachePolicyAlreadyExists":
        case "com.amazonaws.cloudfront#CachePolicyAlreadyExists":
            throw await de_CachePolicyAlreadyExistsRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyCookiesInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInCachePolicy":
            throw await de_TooManyCookiesInCachePolicyRes(parsedOutput, context);
        case "TooManyHeadersInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInCachePolicy":
            throw await de_TooManyHeadersInCachePolicyRes(parsedOutput, context);
        case "TooManyQueryStringsInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInCachePolicy":
            throw await de_TooManyQueryStringsInCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentity = de_CloudFrontOriginAccessIdentity(data, context);
    return contents;
};
exports.de_UpdateCloudFrontOriginAccessIdentityCommand = de_UpdateCloudFrontOriginAccessIdentityCommand;
const de_UpdateCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await de_NoSuchCloudFrontOriginAccessIdentityRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicy = de_ContinuousDeploymentPolicy(data, context);
    return contents;
};
exports.de_UpdateContinuousDeploymentPolicyCommand = de_UpdateContinuousDeploymentPolicyCommand;
const de_UpdateContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "StagingDistributionInUse":
        case "com.amazonaws.cloudfront#StagingDistributionInUse":
            throw await de_StagingDistributionInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_UpdateDistributionCommand = de_UpdateDistributionCommand;
const de_UpdateDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyInUse":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyInUse":
            throw await de_ContinuousDeploymentPolicyInUseRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "IllegalOriginAccessConfiguration":
        case "com.amazonaws.cloudfront#IllegalOriginAccessConfiguration":
            throw await de_IllegalOriginAccessConfigurationRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidDomainNameForOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidDomainNameForOriginAccessControl":
            throw await de_InvalidDomainNameForOriginAccessControlRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "StagingDistributionInUse":
        case "com.amazonaws.cloudfront#StagingDistributionInUse":
            throw await de_StagingDistributionInUseRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateDistributionWithStagingConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDistributionWithStagingConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_UpdateDistributionWithStagingConfigCommand = de_UpdateDistributionWithStagingConfigCommand;
const de_UpdateDistributionWithStagingConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryption = de_FieldLevelEncryption(data, context);
    return contents;
};
exports.de_UpdateFieldLevelEncryptionConfigCommand = de_UpdateFieldLevelEncryptionConfigCommand;
const de_UpdateFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "QueryArgProfileEmpty":
        case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
            throw await de_QueryArgProfileEmptyRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionContentTypeProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
            throw await de_TooManyFieldLevelEncryptionContentTypeProfilesRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionQueryArgProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
            throw await de_TooManyFieldLevelEncryptionQueryArgProfilesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfile = de_FieldLevelEncryptionProfile(data, context);
    return contents;
};
exports.de_UpdateFieldLevelEncryptionProfileCommand = de_UpdateFieldLevelEncryptionProfileCommand;
const de_UpdateFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "FieldLevelEncryptionProfileAlreadyExists":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
            throw await de_FieldLevelEncryptionProfileAlreadyExistsRes(parsedOutput, context);
        case "FieldLevelEncryptionProfileSizeExceeded":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
            throw await de_FieldLevelEncryptionProfileSizeExceededRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionEncryptionEntities":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
            throw await de_TooManyFieldLevelEncryptionEncryptionEntitiesRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionFieldPatterns":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
            throw await de_TooManyFieldLevelEncryptionFieldPatternsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_et]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = de_FunctionSummary(data, context);
    return contents;
};
exports.de_UpdateFunctionCommand = de_UpdateFunctionCommand;
const de_UpdateFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FunctionSizeLimitExceeded":
        case "com.amazonaws.cloudfront#FunctionSizeLimitExceeded":
            throw await de_FunctionSizeLimitExceededRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroup = de_KeyGroup(data, context);
    return contents;
};
exports.de_UpdateKeyGroupCommand = de_UpdateKeyGroupCommand;
const de_UpdateKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "KeyGroupAlreadyExists":
        case "com.amazonaws.cloudfront#KeyGroupAlreadyExists":
            throw await de_KeyGroupAlreadyExistsRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyPublicKeysInKeyGroup":
        case "com.amazonaws.cloudfront#TooManyPublicKeysInKeyGroup":
            throw await de_TooManyPublicKeysInKeyGroupRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateKeyValueStoreCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateKeyValueStoreCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyValueStore = de_KeyValueStore(data, context);
    return contents;
};
exports.de_UpdateKeyValueStoreCommand = de_UpdateKeyValueStoreCommand;
const de_UpdateKeyValueStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "EntityNotFound":
        case "com.amazonaws.cloudfront#EntityNotFound":
            throw await de_EntityNotFoundRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateOriginAccessControlCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControl = de_OriginAccessControl(data, context);
    return contents;
};
exports.de_UpdateOriginAccessControlCommand = de_UpdateOriginAccessControlCommand;
const de_UpdateOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await de_NoSuchOriginAccessControlRes(parsedOutput, context);
        case "OriginAccessControlAlreadyExists":
        case "com.amazonaws.cloudfront#OriginAccessControlAlreadyExists":
            throw await de_OriginAccessControlAlreadyExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateOriginRequestPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicy = de_OriginRequestPolicy(data, context);
    return contents;
};
exports.de_UpdateOriginRequestPolicyCommand = de_UpdateOriginRequestPolicyCommand;
const de_UpdateOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "OriginRequestPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#OriginRequestPolicyAlreadyExists":
            throw await de_OriginRequestPolicyAlreadyExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyCookiesInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInOriginRequestPolicy":
            throw await de_TooManyCookiesInOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyHeadersInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInOriginRequestPolicy":
            throw await de_TooManyHeadersInOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyQueryStringsInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInOriginRequestPolicy":
            throw await de_TooManyQueryStringsInOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdatePublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdatePublicKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKey = de_PublicKey(data, context);
    return contents;
};
exports.de_UpdatePublicKeyCommand = de_UpdatePublicKeyCommand;
const de_UpdatePublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CannotChangeImmutablePublicKeyFields":
        case "com.amazonaws.cloudfront#CannotChangeImmutablePublicKeyFields":
            throw await de_CannotChangeImmutablePublicKeyFieldsRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_RLC] != null) {
        contents[_RLC] = de_RealtimeLogConfig(data[_RLC], context);
    }
    return contents;
};
exports.de_UpdateRealtimeLogConfigCommand = de_UpdateRealtimeLogConfigCommand;
const de_UpdateRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateResponseHeadersPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicy = de_ResponseHeadersPolicy(data, context);
    return contents;
};
exports.de_UpdateResponseHeadersPolicyCommand = de_UpdateResponseHeadersPolicyCommand;
const de_UpdateResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "ResponseHeadersPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#ResponseHeadersPolicyAlreadyExists":
            throw await de_ResponseHeadersPolicyAlreadyExistsRes(parsedOutput, context);
        case "TooLongCSPInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooLongCSPInResponseHeadersPolicy":
            throw await de_TooLongCSPInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyCustomHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyCustomHeadersInResponseHeadersPolicy":
            throw await de_TooManyCustomHeadersInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyRemoveHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyRemoveHeadersInResponseHeadersPolicy":
            throw await de_TooManyRemoveHeadersInResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStreamingDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = de_StreamingDistribution(data, context);
    return contents;
};
exports.de_UpdateStreamingDistributionCommand = de_UpdateStreamingDistributionCommand;
const de_UpdateStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await de_NoSuchStreamingDistributionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyStreamingDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
            throw await de_TooManyStreamingDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(CloudFrontServiceException_1.CloudFrontServiceException);
const de_AccessDeniedRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.AccessDenied({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_BatchTooLargeRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.BatchTooLarge({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CachePolicyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CachePolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CachePolicyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CachePolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CannotChangeImmutablePublicKeyFieldsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CannotChangeImmutablePublicKeyFields({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CannotDeleteEntityWhileInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CannotDeleteEntityWhileInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CloudFrontOriginAccessIdentityAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CloudFrontOriginAccessIdentityAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CloudFrontOriginAccessIdentityInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.CloudFrontOriginAccessIdentityInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CNAMEAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CNAMEAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ContinuousDeploymentPolicyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.ContinuousDeploymentPolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ContinuousDeploymentPolicyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.ContinuousDeploymentPolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_DistributionAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.DistributionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_DistributionNotDisabledRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.DistributionNotDisabled({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_EntityAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.EntityAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_EntityLimitExceededRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.EntityLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_EntityNotFoundRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.EntityNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_EntitySizeLimitExceededRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.EntitySizeLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionConfigAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FieldLevelEncryptionConfigAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionConfigInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.FieldLevelEncryptionConfigInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionProfileAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FieldLevelEncryptionProfileAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionProfileInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.FieldLevelEncryptionProfileInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionProfileSizeExceededRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FieldLevelEncryptionProfileSizeExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FunctionAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FunctionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FunctionInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.FunctionInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FunctionSizeLimitExceededRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FunctionSizeLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_IllegalDeleteRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.IllegalDelete({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_IllegalOriginAccessConfigurationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.IllegalOriginAccessConfiguration({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_IllegalUpdateRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.IllegalUpdate({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InconsistentQuantitiesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InconsistentQuantities({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidArgumentRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidArgument({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidDefaultRootObjectRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidDefaultRootObject({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidDomainNameForOriginAccessControlRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidDomainNameForOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidErrorCodeRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidErrorCode({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidForwardCookiesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidForwardCookies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidFunctionAssociationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidFunctionAssociation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidGeoRestrictionParameterRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidGeoRestrictionParameter({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidHeadersForS3OriginRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidHeadersForS3Origin({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidIfMatchVersionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidIfMatchVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidLambdaFunctionAssociationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidLambdaFunctionAssociation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidLocationCodeRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidLocationCode({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidMinimumProtocolVersionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidMinimumProtocolVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOrigin({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginAccessControlRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginAccessIdentityRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOriginAccessIdentity({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginKeepaliveTimeoutRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOriginKeepaliveTimeout({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginReadTimeoutRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOriginReadTimeout({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidProtocolSettingsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidProtocolSettings({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidQueryStringParametersRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidQueryStringParameters({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidRelativePathRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidRelativePath({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidRequiredProtocolRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidRequiredProtocol({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidResponseCodeRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidResponseCode({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidTaggingRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidTagging({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidTTLOrderRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidTTLOrder({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidViewerCertificateRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidViewerCertificate({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidWebACLIdRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidWebACLId({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_KeyGroupAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.KeyGroupAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_MissingBodyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.MissingBody({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_MonitoringSubscriptionAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.MonitoringSubscriptionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchCloudFrontOriginAccessIdentityRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchCloudFrontOriginAccessIdentity({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchContinuousDeploymentPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchContinuousDeploymentPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchDistributionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchFieldLevelEncryptionConfigRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchFieldLevelEncryptionConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchFieldLevelEncryptionProfileRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchFieldLevelEncryptionProfile({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchFunctionExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchFunctionExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchInvalidationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchInvalidation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchMonitoringSubscriptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchMonitoringSubscription({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchOriginRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchOrigin({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchOriginAccessControlRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchPublicKeyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchPublicKey({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchRealtimeLogConfigRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchRealtimeLogConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchResourceRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchResource({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchStreamingDistributionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchStreamingDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_OriginAccessControlAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.OriginAccessControlAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_OriginAccessControlInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.OriginAccessControlInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_OriginRequestPolicyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.OriginRequestPolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_OriginRequestPolicyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.OriginRequestPolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_PreconditionFailedRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.PreconditionFailed({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_PublicKeyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.PublicKeyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_PublicKeyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.PublicKeyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_QueryArgProfileEmptyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.QueryArgProfileEmpty({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_RealtimeLogConfigAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.RealtimeLogConfigAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_RealtimeLogConfigInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.RealtimeLogConfigInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_RealtimeLogConfigOwnerMismatchRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.RealtimeLogConfigOwnerMismatch({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ResourceInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.ResourceInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ResponseHeadersPolicyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.ResponseHeadersPolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ResponseHeadersPolicyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.ResponseHeadersPolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_StagingDistributionInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.StagingDistributionInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_StreamingDistributionAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.StreamingDistributionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_StreamingDistributionNotDisabledRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.StreamingDistributionNotDisabled({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TestFunctionFailedRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TestFunctionFailed({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooLongCSPInResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooLongCSPInResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCacheBehaviorsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCacheBehaviors({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCachePoliciesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCachePolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCertificatesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCertificates({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCloudFrontOriginAccessIdentitiesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCloudFrontOriginAccessIdentities({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyContinuousDeploymentPoliciesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyContinuousDeploymentPolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCookieNamesInWhiteListRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCookieNamesInWhiteList({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCookiesInCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCookiesInCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCookiesInOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCookiesInOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCustomHeadersInResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyCustomHeadersInResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionCNAMEsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionCNAMEs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributions({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToFieldLevelEncryptionConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToKeyGroupRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToKeyGroup({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToOriginAccessControlRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsWithFunctionAssociationsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsWithFunctionAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsWithLambdaAssociationsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsWithLambdaAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsWithSingleFunctionARNRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsWithSingleFunctionARN({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionConfigsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionConfigs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionContentTypeProfilesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionContentTypeProfiles({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionEncryptionEntitiesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionEncryptionEntities({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionFieldPatternsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionFieldPatterns({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionProfilesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionProfiles({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionQueryArgProfilesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionQueryArgProfiles({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFunctionAssociationsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFunctionAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFunctionsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFunctions({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyHeadersInCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyHeadersInCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyHeadersInForwardedValuesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyHeadersInForwardedValues({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyHeadersInOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyHeadersInOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyInvalidationsInProgressRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyInvalidationsInProgress({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyKeyGroupsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyKeyGroups({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyKeyGroupsAssociatedToDistributionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyKeyGroupsAssociatedToDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyLambdaFunctionAssociationsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyLambdaFunctionAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginAccessControlsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOriginAccessControls({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginCustomHeadersRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOriginCustomHeaders({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginGroupsPerDistributionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOriginGroupsPerDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginRequestPoliciesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOriginRequestPolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOrigins({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyPublicKeysRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyPublicKeys({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyPublicKeysInKeyGroupRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyPublicKeysInKeyGroup({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyQueryStringParametersRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyQueryStringParameters({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyQueryStringsInCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyQueryStringsInCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyQueryStringsInOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyQueryStringsInOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyRealtimeLogConfigsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyRealtimeLogConfigs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyRemoveHeadersInResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyRemoveHeadersInResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyResponseHeadersPoliciesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyResponseHeadersPolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyStreamingDistributionCNAMEsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyStreamingDistributionCNAMEs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyStreamingDistributionsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyStreamingDistributions({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyTrustedSignersRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyTrustedSigners({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TrustedKeyGroupDoesNotExistRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TrustedKeyGroupDoesNotExist({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TrustedSignerDoesNotExistRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TrustedSignerDoesNotExist({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_UnsupportedOperationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.UnsupportedOperation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const se_AccessControlAllowHeadersList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_H);
    });
};
const se_AccessControlAllowMethodsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_RHPACAMV, entry);
        return n.n(_Met);
    });
};
const se_AccessControlAllowOriginsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_Or);
    });
};
const se_AccessControlExposeHeadersList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_H);
    });
};
const se_Aliases = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Al);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AliasList(input[_It], context));
    return bn;
};
const se_AliasList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_CNAME);
    });
};
const se_AllowedMethods = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_AM);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_MethodsList(input[_It], context));
    if (input[_CM] != null) {
        bn.c(se_CachedMethods(input[_CM], context).n(_CM));
    }
    return bn;
};
const se_AwsAccountNumberList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_AAN);
    });
};
const se_CacheBehavior = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CB);
    if (input[_PP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PP]).n(_PP));
    }
    if (input[_TOI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_TOI]).n(_TOI));
    }
    if (input[_TS] != null) {
        bn.c(se_TrustedSigners(input[_TS], context).n(_TS));
    }
    if (input[_TKG] != null) {
        bn.c(se_TrustedKeyGroups(input[_TKG], context).n(_TKG));
    }
    bn.cc(input, _VPP);
    if (input[_AM] != null) {
        bn.c(se_AllowedMethods(input[_AM], context).n(_AM));
    }
    if (input[_SS] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_SS])).n(_SS));
    }
    if (input[_Co] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Co])).n(_Co));
    }
    if (input[_LFA] != null) {
        bn.c(se_LambdaFunctionAssociations(input[_LFA], context).n(_LFA));
    }
    if (input[_FA] != null) {
        bn.c(se_FunctionAssociations(input[_FA], context).n(_FA));
    }
    if (input[_FLEI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_FLEI]).n(_FLEI));
    }
    if (input[_RLCA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RLCA]).n(_RLCA));
    }
    if (input[_CPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CPI]).n(_CPI));
    }
    if (input[_ORPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ORPI]).n(_ORPI));
    }
    if (input[_RHPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RHPI]).n(_RHPI));
    }
    if (input[_FV] != null) {
        bn.c(se_ForwardedValues(input[_FV], context).n(_FV));
    }
    if (input[_MTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTL])).n(_MTTL));
    }
    if (input[_DTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_DTTL])).n(_DTTL));
    }
    if (input[_MTTLa] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTLa])).n(_MTTLa));
    }
    return bn;
};
const se_CacheBehaviorList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_CacheBehavior(entry, context);
        return n.n(_CB);
    });
};
const se_CacheBehaviors = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CBa);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_CacheBehaviorList(input[_It], context));
    return bn;
};
const se_CachedMethods = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CM);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_MethodsList(input[_It], context));
    return bn;
};
const se_CachePolicyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CPC);
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_DTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_DTTL])).n(_DTTL));
    }
    if (input[_MTTLa] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTLa])).n(_MTTLa));
    }
    if (input[_MTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTL])).n(_MTTL));
    }
    if (input[_PICKAFTO] != null) {
        bn.c(se_ParametersInCacheKeyAndForwardedToOrigin(input[_PICKAFTO], context).n(_PICKAFTO));
    }
    return bn;
};
const se_CachePolicyCookiesConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CPCC);
    if (input[_CBo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CPCB, input[_CBo]).n(_CBo));
    }
    if (input[_Coo] != null) {
        bn.c(se_CookieNames(input[_Coo], context).n(_Coo));
    }
    return bn;
};
const se_CachePolicyHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CPHC);
    if (input[_HB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CPHB, input[_HB]).n(_HB));
    }
    if (input[_He] != null) {
        bn.c(se_Headers(input[_He], context).n(_He));
    }
    return bn;
};
const se_CachePolicyQueryStringsConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CPQSC);
    if (input[_QSB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CPQSB, input[_QSB]).n(_QSB));
    }
    if (input[_QS] != null) {
        bn.c(se_QueryStringNames(input[_QS], context).n(_QS));
    }
    return bn;
};
const se_CloudFrontOriginAccessIdentityConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CFOAIC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    return bn;
};
const se_ContentTypeProfile = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CTP);
    bn.cc(input, _Fo);
    if (input[_PI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PI]).n(_PI));
    }
    if (input[_CT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CT]).n(_CT));
    }
    return bn;
};
const se_ContentTypeProfileConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CTPC);
    if (input[_FWCTIU] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_FWCTIU])).n(_FWCTIU));
    }
    if (input[_CTPo] != null) {
        bn.c(se_ContentTypeProfiles(input[_CTPo], context).n(_CTPo));
    }
    return bn;
};
const se_ContentTypeProfileList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_ContentTypeProfile(entry, context);
        return n.n(_CTP);
    });
};
const se_ContentTypeProfiles = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CTPo);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_ContentTypeProfileList(input[_It], context));
    return bn;
};
const se_ContinuousDeploymentPolicyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CDPC);
    if (input[_SDDN] != null) {
        bn.c(se_StagingDistributionDnsNames(input[_SDDN], context).n(_SDDN));
    }
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_TC] != null) {
        bn.c(se_TrafficConfig(input[_TC], context).n(_TC));
    }
    return bn;
};
const se_ContinuousDeploymentSingleHeaderConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CDSHC);
    if (input[_H] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_H]).n(_H));
    }
    if (input[_V] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_V]).n(_V));
    }
    return bn;
};
const se_ContinuousDeploymentSingleWeightConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CDSWC);
    if (input[_W] != null) {
        bn.c(xml_builder_1.XmlNode.of(_f, String(input[_W])).n(_W));
    }
    if (input[_SSC] != null) {
        bn.c(se_SessionStickinessConfig(input[_SSC], context).n(_SSC));
    }
    return bn;
};
const se_CookieNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_N);
    });
};
const se_CookieNames = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CN);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_CookieNameList(input[_It], context));
    return bn;
};
const se_CookiePreference = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CP);
    if (input[_For] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ISt, input[_For]).n(_For));
    }
    if (input[_WN] != null) {
        bn.c(se_CookieNames(input[_WN], context).n(_WN));
    }
    return bn;
};
const se_CustomErrorResponse = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CER);
    if (input[_EC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_EC])).n(_EC));
    }
    if (input[_RPP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RPP]).n(_RPP));
    }
    if (input[_RC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RC]).n(_RC));
    }
    if (input[_ECMTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_ECMTTL])).n(_ECMTTL));
    }
    return bn;
};
const se_CustomErrorResponseList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_CustomErrorResponse(entry, context);
        return n.n(_CER);
    });
};
const se_CustomErrorResponses = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CERu);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_CustomErrorResponseList(input[_It], context));
    return bn;
};
const se_CustomHeaders = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CH);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_OriginCustomHeadersList(input[_It], context));
    return bn;
};
const se_CustomOriginConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_COC);
    if (input[_HTTPP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_HTTPP])).n(_HTTPP));
    }
    if (input[_HTTPSP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_HTTPSP])).n(_HTTPSP));
    }
    bn.cc(input, _OPP);
    if (input[_OSP] != null) {
        bn.c(se_OriginSslProtocols(input[_OSP], context).n(_OSP));
    }
    if (input[_ORT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_ORT])).n(_ORT));
    }
    if (input[_OKT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_OKT])).n(_OKT));
    }
    return bn;
};
const se_DefaultCacheBehavior = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_DCB);
    if (input[_TOI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_TOI]).n(_TOI));
    }
    if (input[_TS] != null) {
        bn.c(se_TrustedSigners(input[_TS], context).n(_TS));
    }
    if (input[_TKG] != null) {
        bn.c(se_TrustedKeyGroups(input[_TKG], context).n(_TKG));
    }
    bn.cc(input, _VPP);
    if (input[_AM] != null) {
        bn.c(se_AllowedMethods(input[_AM], context).n(_AM));
    }
    if (input[_SS] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_SS])).n(_SS));
    }
    if (input[_Co] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Co])).n(_Co));
    }
    if (input[_LFA] != null) {
        bn.c(se_LambdaFunctionAssociations(input[_LFA], context).n(_LFA));
    }
    if (input[_FA] != null) {
        bn.c(se_FunctionAssociations(input[_FA], context).n(_FA));
    }
    if (input[_FLEI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_FLEI]).n(_FLEI));
    }
    if (input[_RLCA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RLCA]).n(_RLCA));
    }
    if (input[_CPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CPI]).n(_CPI));
    }
    if (input[_ORPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ORPI]).n(_ORPI));
    }
    if (input[_RHPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RHPI]).n(_RHPI));
    }
    if (input[_FV] != null) {
        bn.c(se_ForwardedValues(input[_FV], context).n(_FV));
    }
    if (input[_MTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTL])).n(_MTTL));
    }
    if (input[_DTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_DTTL])).n(_DTTL));
    }
    if (input[_MTTLa] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTLa])).n(_MTTLa));
    }
    return bn;
};
const se_DistributionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_DC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_Al] != null) {
        bn.c(se_Aliases(input[_Al], context).n(_Al));
    }
    if (input[_DRO] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_DRO]).n(_DRO));
    }
    if (input[_Ori] != null) {
        bn.c(se_Origins(input[_Ori], context).n(_Ori));
    }
    if (input[_OG] != null) {
        bn.c(se_OriginGroups(input[_OG], context).n(_OG));
    }
    if (input[_DCB] != null) {
        bn.c(se_DefaultCacheBehavior(input[_DCB], context).n(_DCB));
    }
    if (input[_CBa] != null) {
        bn.c(se_CacheBehaviors(input[_CBa], context).n(_CBa));
    }
    if (input[_CERu] != null) {
        bn.c(se_CustomErrorResponses(input[_CERu], context).n(_CERu));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CTo, input[_C]).n(_C));
    }
    if (input[_Lo] != null) {
        bn.c(se_LoggingConfig(input[_Lo], context).n(_Lo));
    }
    bn.cc(input, _PC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_VC] != null) {
        bn.c(se_ViewerCertificate(input[_VC], context).n(_VC));
    }
    if (input[_Re] != null) {
        bn.c(se_Restrictions(input[_Re], context).n(_Re));
    }
    if (input[_WACLI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_WACLI]).n(_WACLI));
    }
    bn.cc(input, _HV);
    if (input[_IIPVE] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_IIPVE])).n(_IIPVE));
    }
    if (input[_CDPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CDPI]).n(_CDPI));
    }
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_S])).n(_S));
    }
    return bn;
};
const se_DistributionConfigWithTags = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_DCWT);
    if (input[_DC] != null) {
        bn.c(se_DistributionConfig(input[_DC], context).n(_DC));
    }
    if (input[_Ta] != null) {
        bn.c(se_Tags(input[_Ta], context).n(_Ta));
    }
    return bn;
};
const se_EncryptionEntities = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_EE);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_EncryptionEntityList(input[_It], context));
    return bn;
};
const se_EncryptionEntity = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_EEn);
    if (input[_PKI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PKI]).n(_PKI));
    }
    if (input[_PIr] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PIr]).n(_PIr));
    }
    if (input[_FP] != null) {
        bn.c(se_FieldPatterns(input[_FP], context).n(_FP));
    }
    return bn;
};
const se_EncryptionEntityList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_EncryptionEntity(entry, context);
        return n.n(_EEn);
    });
};
const se_EndPoint = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_EPn);
    if (input[_ST] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ST]).n(_ST));
    }
    if (input[_KSC] != null) {
        bn.c(se_KinesisStreamConfig(input[_KSC], context).n(_KSC));
    }
    return bn;
};
const se_EndPointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_EndPoint(entry, context);
        return n.n(_m);
    });
};
const se_FieldLevelEncryptionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FLEC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_QAPC] != null) {
        bn.c(se_QueryArgProfileConfig(input[_QAPC], context).n(_QAPC));
    }
    if (input[_CTPC] != null) {
        bn.c(se_ContentTypeProfileConfig(input[_CTPC], context).n(_CTPC));
    }
    return bn;
};
const se_FieldLevelEncryptionProfileConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FLEPC);
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_EE] != null) {
        bn.c(se_EncryptionEntities(input[_EE], context).n(_EE));
    }
    return bn;
};
const se_FieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_Fi);
    });
};
const se_FieldPatternList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_FPi);
    });
};
const se_FieldPatterns = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FP);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_FieldPatternList(input[_It], context));
    return bn;
};
const se_ForwardedValues = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FV);
    if (input[_QSu] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_QSu])).n(_QSu));
    }
    if (input[_Coo] != null) {
        bn.c(se_CookiePreference(input[_Coo], context).n(_Coo));
    }
    if (input[_He] != null) {
        bn.c(se_Headers(input[_He], context).n(_He));
    }
    if (input[_QSCK] != null) {
        bn.c(se_QueryStringCacheKeys(input[_QSCK], context).n(_QSCK));
    }
    return bn;
};
const se_FunctionAssociation = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FAu);
    bn.cc(input, _FARN);
    bn.cc(input, _ETv);
    return bn;
};
const se_FunctionAssociationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_FunctionAssociation(entry, context);
        return n.n(_FAu);
    });
};
const se_FunctionAssociations = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FA);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_FunctionAssociationList(input[_It], context));
    return bn;
};
const se_FunctionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FCu);
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_Ru] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FR, input[_Ru]).n(_Ru));
    }
    if (input[_KVSA] != null) {
        bn.c(se_KeyValueStoreAssociations(input[_KVSA], context).n(_KVSA));
    }
    return bn;
};
const se_GeoRestriction = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_GR);
    if (input[_RT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_GRT, input[_RT]).n(_RT));
    }
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_LocationList(input[_It], context));
    return bn;
};
const se_HeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_N);
    });
};
const se_Headers = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_He);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_HeaderList(input[_It], context));
    return bn;
};
const se_ImportSource = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_IS);
    if (input[_STo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_IST, input[_STo]).n(_STo));
    }
    if (input[_SARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_SARN]).n(_SARN));
    }
    return bn;
};
const se_InvalidationBatch = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_IB);
    if (input[_P] != null) {
        bn.c(se_Paths(input[_P], context).n(_P));
    }
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    return bn;
};
const se_KeyGroupConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_KGC);
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    bn.lc(input, "Items", "Items", () => se_PublicKeyIdList(input[_It], context));
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    return bn;
};
const se_KeyValueStoreAssociation = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_KVSAe);
    bn.cc(input, _KVSARN);
    return bn;
};
const se_KeyValueStoreAssociationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_KeyValueStoreAssociation(entry, context);
        return n.n(_KVSAe);
    });
};
const se_KeyValueStoreAssociations = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_KVSA);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_KeyValueStoreAssociationList(input[_It], context));
    return bn;
};
const se_KinesisStreamConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_KSC);
    if (input[_RARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RARN]).n(_RARN));
    }
    if (input[_SARNt] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_SARNt]).n(_SARNt));
    }
    return bn;
};
const se_LambdaFunctionAssociation = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LFAa);
    bn.cc(input, _LFARN);
    bn.cc(input, _ETv);
    if (input[_IBn] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_IBn])).n(_IBn));
    }
    return bn;
};
const se_LambdaFunctionAssociationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_LambdaFunctionAssociation(entry, context);
        return n.n(_LFAa);
    });
};
const se_LambdaFunctionAssociations = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LFA);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_LambdaFunctionAssociationList(input[_It], context));
    return bn;
};
const se_LocationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_L);
    });
};
const se_LoggingConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_IC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_IC])).n(_IC));
    }
    if (input[_B] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_B]).n(_B));
    }
    if (input[_Pr] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Pr]).n(_Pr));
    }
    return bn;
};
const se_MethodsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_Met, entry);
        return n.n(_Met);
    });
};
const se_MonitoringSubscription = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_MS);
    if (input[_RMSC] != null) {
        bn.c(se_RealtimeMetricsSubscriptionConfig(input[_RMSC], context).n(_RMSC));
    }
    return bn;
};
const se_Origin = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Or);
    if (input[_Id] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Id]).n(_Id));
    }
    if (input[_DN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_DN]).n(_DN));
    }
    if (input[_OP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OP]).n(_OP));
    }
    if (input[_CH] != null) {
        bn.c(se_CustomHeaders(input[_CH], context).n(_CH));
    }
    if (input[_SOC] != null) {
        bn.c(se_S3OriginConfig(input[_SOC], context).n(_SOC));
    }
    if (input[_COC] != null) {
        bn.c(se_CustomOriginConfig(input[_COC], context).n(_COC));
    }
    if (input[_CA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_CA])).n(_CA));
    }
    if (input[_CTon] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_CTon])).n(_CTon));
    }
    if (input[_OS] != null) {
        bn.c(se_OriginShield(input[_OS], context).n(_OS));
    }
    if (input[_OACI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OACI]).n(_OACI));
    }
    return bn;
};
const se_OriginAccessControlConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OACC);
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_D] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_D]).n(_D));
    }
    if (input[_SP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OACSP, input[_SP]).n(_SP));
    }
    if (input[_SB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OACSB, input[_SB]).n(_SB));
    }
    if (input[_OACOT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OACOTr, input[_OACOT]).n(_OACOT));
    }
    return bn;
};
const se_OriginCustomHeader = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OCH);
    if (input[_HN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_HN]).n(_HN));
    }
    if (input[_HVe] != null) {
        bn.c(xml_builder_1.XmlNode.of(_sST, input[_HVe]).n(_HVe));
    }
    return bn;
};
const se_OriginCustomHeadersList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_OriginCustomHeader(entry, context);
        return n.n(_OCH);
    });
};
const se_OriginGroup = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OGr);
    if (input[_Id] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Id]).n(_Id));
    }
    if (input[_FCa] != null) {
        bn.c(se_OriginGroupFailoverCriteria(input[_FCa], context).n(_FCa));
    }
    if (input[_Mem] != null) {
        bn.c(se_OriginGroupMembers(input[_Mem], context).n(_Mem));
    }
    return bn;
};
const se_OriginGroupFailoverCriteria = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OGFC);
    if (input[_SC] != null) {
        bn.c(se_StatusCodes(input[_SC], context).n(_SC));
    }
    return bn;
};
const se_OriginGroupList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_OriginGroup(entry, context);
        return n.n(_OGr);
    });
};
const se_OriginGroupMember = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OGM);
    if (input[_OI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OI]).n(_OI));
    }
    return bn;
};
const se_OriginGroupMemberList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_OriginGroupMember(entry, context);
        return n.n(_OGM);
    });
};
const se_OriginGroupMembers = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OGMr);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_OriginGroupMemberList(input[_It], context));
    return bn;
};
const se_OriginGroups = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OG);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_OriginGroupList(input[_It], context));
    return bn;
};
const se_OriginList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_Origin(entry, context);
        return n.n(_Or);
    });
};
const se_OriginRequestPolicyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ORPC);
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_HC] != null) {
        bn.c(se_OriginRequestPolicyHeadersConfig(input[_HC], context).n(_HC));
    }
    if (input[_CC] != null) {
        bn.c(se_OriginRequestPolicyCookiesConfig(input[_CC], context).n(_CC));
    }
    if (input[_QSC] != null) {
        bn.c(se_OriginRequestPolicyQueryStringsConfig(input[_QSC], context).n(_QSC));
    }
    return bn;
};
const se_OriginRequestPolicyCookiesConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ORPCC);
    if (input[_CBo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ORPCB, input[_CBo]).n(_CBo));
    }
    if (input[_Coo] != null) {
        bn.c(se_CookieNames(input[_Coo], context).n(_Coo));
    }
    return bn;
};
const se_OriginRequestPolicyHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ORPHC);
    if (input[_HB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ORPHB, input[_HB]).n(_HB));
    }
    if (input[_He] != null) {
        bn.c(se_Headers(input[_He], context).n(_He));
    }
    return bn;
};
const se_OriginRequestPolicyQueryStringsConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ORPQSC);
    if (input[_QSB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ORPQSB, input[_QSB]).n(_QSB));
    }
    if (input[_QS] != null) {
        bn.c(se_QueryStringNames(input[_QS], context).n(_QS));
    }
    return bn;
};
const se_Origins = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Ori);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_OriginList(input[_It], context));
    return bn;
};
const se_OriginShield = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OS);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    bn.cc(input, _OSR);
    return bn;
};
const se_OriginSslProtocols = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OSP);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_SslProtocolsList(input[_It], context));
    return bn;
};
const se_ParametersInCacheKeyAndForwardedToOrigin = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_PICKAFTO);
    if (input[_EAEG] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_EAEG])).n(_EAEG));
    }
    if (input[_EAEB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_EAEB])).n(_EAEB));
    }
    if (input[_HC] != null) {
        bn.c(se_CachePolicyHeadersConfig(input[_HC], context).n(_HC));
    }
    if (input[_CC] != null) {
        bn.c(se_CachePolicyCookiesConfig(input[_CC], context).n(_CC));
    }
    if (input[_QSC] != null) {
        bn.c(se_CachePolicyQueryStringsConfig(input[_QSC], context).n(_QSC));
    }
    return bn;
};
const se_PathList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_Pa);
    });
};
const se_Paths = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_P);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_PathList(input[_It], context));
    return bn;
};
const se_PublicKeyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_PKC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_EK] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_EK]).n(_EK));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    return bn;
};
const se_PublicKeyIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_PK);
    });
};
const se_QueryArgProfile = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QAP);
    if (input[_QA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_QA]).n(_QA));
    }
    if (input[_PI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PI]).n(_PI));
    }
    return bn;
};
const se_QueryArgProfileConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QAPC);
    if (input[_FWQAPIU] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_FWQAPIU])).n(_FWQAPIU));
    }
    if (input[_QAPu] != null) {
        bn.c(se_QueryArgProfiles(input[_QAPu], context).n(_QAPu));
    }
    return bn;
};
const se_QueryArgProfileList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_QueryArgProfile(entry, context);
        return n.n(_QAP);
    });
};
const se_QueryArgProfiles = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QAPu);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_QueryArgProfileList(input[_It], context));
    return bn;
};
const se_QueryStringCacheKeys = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QSCK);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_QueryStringCacheKeysList(input[_It], context));
    return bn;
};
const se_QueryStringCacheKeysList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_N);
    });
};
const se_QueryStringNames = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QSN);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_QueryStringNamesList(input[_It], context));
    return bn;
};
const se_QueryStringNamesList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_N);
    });
};
const se_RealtimeMetricsSubscriptionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RMSC);
    bn.cc(input, _RMSS);
    return bn;
};
const se_ResponseHeadersPolicyAccessControlAllowHeaders = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPACAH);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AccessControlAllowHeadersList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyAccessControlAllowMethods = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPACAM);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AccessControlAllowMethodsList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyAccessControlAllowOrigins = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPACAO);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AccessControlAllowOriginsList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyAccessControlExposeHeaders = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPACEH);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AccessControlExposeHeadersList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPC);
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_CCo] != null) {
        bn.c(se_ResponseHeadersPolicyCorsConfig(input[_CCo], context).n(_CCo));
    }
    if (input[_SHC] != null) {
        bn.c(se_ResponseHeadersPolicySecurityHeadersConfig(input[_SHC], context).n(_SHC));
    }
    if (input[_STHC] != null) {
        bn.c(se_ResponseHeadersPolicyServerTimingHeadersConfig(input[_STHC], context).n(_STHC));
    }
    if (input[_CHC] != null) {
        bn.c(se_ResponseHeadersPolicyCustomHeadersConfig(input[_CHC], context).n(_CHC));
    }
    if (input[_RHC] != null) {
        bn.c(se_ResponseHeadersPolicyRemoveHeadersConfig(input[_RHC], context).n(_RHC));
    }
    return bn;
};
const se_ResponseHeadersPolicyContentSecurityPolicy = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCSP);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_CSP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CSP]).n(_CSP));
    }
    return bn;
};
const se_ResponseHeadersPolicyContentTypeOptions = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCTO);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    return bn;
};
const se_ResponseHeadersPolicyCorsConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCC);
    if (input[_ACAO] != null) {
        bn.c(se_ResponseHeadersPolicyAccessControlAllowOrigins(input[_ACAO], context).n(_ACAO));
    }
    if (input[_ACAH] != null) {
        bn.c(se_ResponseHeadersPolicyAccessControlAllowHeaders(input[_ACAH], context).n(_ACAH));
    }
    if (input[_ACAM] != null) {
        bn.c(se_ResponseHeadersPolicyAccessControlAllowMethods(input[_ACAM], context).n(_ACAM));
    }
    if (input[_ACAC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_ACAC])).n(_ACAC));
    }
    if (input[_ACEH] != null) {
        bn.c(se_ResponseHeadersPolicyAccessControlExposeHeaders(input[_ACEH], context).n(_ACEH));
    }
    if (input[_ACMAS] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_ACMAS])).n(_ACMAS));
    }
    if (input[_OO] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_OO])).n(_OO));
    }
    return bn;
};
const se_ResponseHeadersPolicyCustomHeader = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCH);
    if (input[_H] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_H]).n(_H));
    }
    if (input[_V] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_V]).n(_V));
    }
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    return bn;
};
const se_ResponseHeadersPolicyCustomHeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_ResponseHeadersPolicyCustomHeader(entry, context);
        return n.n(_RHPCH);
    });
};
const se_ResponseHeadersPolicyCustomHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCHC);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_ResponseHeadersPolicyCustomHeaderList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyFrameOptions = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPFO);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_FO] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FOL, input[_FO]).n(_FO));
    }
    return bn;
};
const se_ResponseHeadersPolicyReferrerPolicy = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPRP);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_RP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_RPL, input[_RP]).n(_RP));
    }
    return bn;
};
const se_ResponseHeadersPolicyRemoveHeader = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPRH);
    if (input[_H] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_H]).n(_H));
    }
    return bn;
};
const se_ResponseHeadersPolicyRemoveHeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_ResponseHeadersPolicyRemoveHeader(entry, context);
        return n.n(_RHPRH);
    });
};
const se_ResponseHeadersPolicyRemoveHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPRHC);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_ResponseHeadersPolicyRemoveHeaderList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicySecurityHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPSHC);
    if (input[_XSSP] != null) {
        bn.c(se_ResponseHeadersPolicyXSSProtection(input[_XSSP], context).n(_XSSP));
    }
    if (input[_FOr] != null) {
        bn.c(se_ResponseHeadersPolicyFrameOptions(input[_FOr], context).n(_FOr));
    }
    if (input[_RP] != null) {
        bn.c(se_ResponseHeadersPolicyReferrerPolicy(input[_RP], context).n(_RP));
    }
    if (input[_CSP] != null) {
        bn.c(se_ResponseHeadersPolicyContentSecurityPolicy(input[_CSP], context).n(_CSP));
    }
    if (input[_CTO] != null) {
        bn.c(se_ResponseHeadersPolicyContentTypeOptions(input[_CTO], context).n(_CTO));
    }
    if (input[_STS] != null) {
        bn.c(se_ResponseHeadersPolicyStrictTransportSecurity(input[_STS], context).n(_STS));
    }
    return bn;
};
const se_ResponseHeadersPolicyServerTimingHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPSTHC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_SR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_SR, String(input[_SR])).n(_SR));
    }
    return bn;
};
const se_ResponseHeadersPolicyStrictTransportSecurity = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPSTS);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_ISn] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_ISn])).n(_ISn));
    }
    if (input[_Pre] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Pre])).n(_Pre));
    }
    if (input[_ACMAS] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_ACMAS])).n(_ACMAS));
    }
    return bn;
};
const se_ResponseHeadersPolicyXSSProtection = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPXSSP);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_Pro] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Pro])).n(_Pro));
    }
    if (input[_MB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_MB])).n(_MB));
    }
    if (input[_RU] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RU]).n(_RU));
    }
    return bn;
};
const se_Restrictions = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Re);
    if (input[_GR] != null) {
        bn.c(se_GeoRestriction(input[_GR], context).n(_GR));
    }
    return bn;
};
const se_S3Origin = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SO);
    if (input[_DN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_DN]).n(_DN));
    }
    if (input[_OAI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OAI]).n(_OAI));
    }
    return bn;
};
const se_S3OriginConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SOC);
    if (input[_OAI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OAI]).n(_OAI));
    }
    return bn;
};
const se_SessionStickinessConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SSC);
    if (input[_ITTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_ITTL])).n(_ITTL));
    }
    if (input[_MTTLax] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_MTTLax])).n(_MTTLax));
    }
    return bn;
};
const se_SslProtocolsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_SPs, entry);
        return n.n(_SPs);
    });
};
const se_StagingDistributionDnsNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_DNn);
    });
};
const se_StagingDistributionDnsNames = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SDDN);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_StagingDistributionDnsNameList(input[_It], context));
    return bn;
};
const se_StatusCodeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_i, String(entry));
        return n.n(_SCt);
    });
};
const se_StatusCodes = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SC);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_StatusCodeList(input[_It], context));
    return bn;
};
const se_StreamingDistributionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SDC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_SO] != null) {
        bn.c(se_S3Origin(input[_SO], context).n(_SO));
    }
    if (input[_Al] != null) {
        bn.c(se_Aliases(input[_Al], context).n(_Al));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_Lo] != null) {
        bn.c(se_StreamingLoggingConfig(input[_Lo], context).n(_Lo));
    }
    if (input[_TS] != null) {
        bn.c(se_TrustedSigners(input[_TS], context).n(_TS));
    }
    bn.cc(input, _PC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    return bn;
};
const se_StreamingDistributionConfigWithTags = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SDCWT);
    if (input[_SDC] != null) {
        bn.c(se_StreamingDistributionConfig(input[_SDC], context).n(_SDC));
    }
    if (input[_Ta] != null) {
        bn.c(se_Tags(input[_Ta], context).n(_Ta));
    }
    return bn;
};
const se_StreamingLoggingConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SLC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_B] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_B]).n(_B));
    }
    if (input[_Pr] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Pr]).n(_Pr));
    }
    return bn;
};
const se_Tag = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Tag);
    if (input[_K] != null) {
        bn.c(xml_builder_1.XmlNode.of(_TK, input[_K]).n(_K));
    }
    if (input[_V] != null) {
        bn.c(xml_builder_1.XmlNode.of(_TV, input[_V]).n(_V));
    }
    return bn;
};
const se_TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_TK, entry);
        return n.n(_K);
    });
};
const se_TagKeys = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TKa);
    bn.lc(input, "Items", "Items", () => se_TagKeyList(input[_It], context));
    return bn;
};
const se_TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_Tag(entry, context);
        return n.n(_Tag);
    });
};
const se_Tags = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Ta);
    bn.lc(input, "Items", "Items", () => se_TagList(input[_It], context));
    return bn;
};
const se_TrafficConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TC);
    if (input[_SWC] != null) {
        bn.c(se_ContinuousDeploymentSingleWeightConfig(input[_SWC], context).n(_SWC));
    }
    if (input[_SHCi] != null) {
        bn.c(se_ContinuousDeploymentSingleHeaderConfig(input[_SHCi], context).n(_SHCi));
    }
    if (input[_T] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CDPT, input[_T]).n(_T));
    }
    return bn;
};
const se_TrustedKeyGroupIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_KG);
    });
};
const se_TrustedKeyGroups = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TKG);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_TrustedKeyGroupIdList(input[_It], context));
    return bn;
};
const se_TrustedSigners = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TS);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AwsAccountNumberList(input[_It], context));
    return bn;
};
const se_ViewerCertificate = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_VC);
    if (input[_CFDC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_CFDC])).n(_CFDC));
    }
    if (input[_IAMCI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_IAMCI]).n(_IAMCI));
    }
    if (input[_ACMCA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ACMCA]).n(_ACMCA));
    }
    bn.cc(input, _SSLSM);
    bn.cc(input, _MPV);
    if (input[_Ce] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Ce]).n(_Ce));
    }
    bn.cc(input, _CS);
    return bn;
};
const de_AccessControlAllowHeadersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AccessControlAllowMethodsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AccessControlAllowOriginsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AccessControlExposeHeadersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_ActiveTrustedKeyGroups = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KG] != null) {
        contents[_It] = de_KGKeyPairIdsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KG]), context);
    }
    return contents;
};
const de_ActiveTrustedSigners = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Si] != null) {
        contents[_It] = de_SignerList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Si]), context);
    }
    return contents;
};
const de_Aliases = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CNAME] != null) {
        contents[_It] = de_AliasList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CNAME]), context);
    }
    return contents;
};
const de_AliasICPRecordal = (output, context) => {
    const contents = {};
    if (output[_CNAME] != null) {
        contents[_CNAME] = (0, smithy_client_1.expectString)(output[_CNAME]);
    }
    if (output[_ICPRS] != null) {
        contents[_ICPRS] = (0, smithy_client_1.expectString)(output[_ICPRS]);
    }
    return contents;
};
const de_AliasICPRecordals = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AliasICPRecordal(entry, context);
    });
};
const de_AliasList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AllowedMethods = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Met] != null) {
        contents[_It] = de_MethodsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Met]), context);
    }
    if (output[_CM] != null) {
        contents[_CM] = de_CachedMethods(output[_CM], context);
    }
    return contents;
};
const de_AwsAccountNumberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_CacheBehavior = (output, context) => {
    const contents = {};
    if (output[_PP] != null) {
        contents[_PP] = (0, smithy_client_1.expectString)(output[_PP]);
    }
    if (output[_TOI] != null) {
        contents[_TOI] = (0, smithy_client_1.expectString)(output[_TOI]);
    }
    if (output[_TS] != null) {
        contents[_TS] = de_TrustedSigners(output[_TS], context);
    }
    if (output[_TKG] != null) {
        contents[_TKG] = de_TrustedKeyGroups(output[_TKG], context);
    }
    if (output[_VPP] != null) {
        contents[_VPP] = (0, smithy_client_1.expectString)(output[_VPP]);
    }
    if (output[_AM] != null) {
        contents[_AM] = de_AllowedMethods(output[_AM], context);
    }
    if (output[_SS] != null) {
        contents[_SS] = (0, smithy_client_1.parseBoolean)(output[_SS]);
    }
    if (output[_Co] != null) {
        contents[_Co] = (0, smithy_client_1.parseBoolean)(output[_Co]);
    }
    if (output[_LFA] != null) {
        contents[_LFA] = de_LambdaFunctionAssociations(output[_LFA], context);
    }
    if (output[_FA] != null) {
        contents[_FA] = de_FunctionAssociations(output[_FA], context);
    }
    if (output[_FLEI] != null) {
        contents[_FLEI] = (0, smithy_client_1.expectString)(output[_FLEI]);
    }
    if (output[_RLCA] != null) {
        contents[_RLCA] = (0, smithy_client_1.expectString)(output[_RLCA]);
    }
    if (output[_CPI] != null) {
        contents[_CPI] = (0, smithy_client_1.expectString)(output[_CPI]);
    }
    if (output[_ORPI] != null) {
        contents[_ORPI] = (0, smithy_client_1.expectString)(output[_ORPI]);
    }
    if (output[_RHPI] != null) {
        contents[_RHPI] = (0, smithy_client_1.expectString)(output[_RHPI]);
    }
    if (output[_FV] != null) {
        contents[_FV] = de_ForwardedValues(output[_FV], context);
    }
    if (output[_MTTL] != null) {
        contents[_MTTL] = (0, smithy_client_1.strictParseLong)(output[_MTTL]);
    }
    if (output[_DTTL] != null) {
        contents[_DTTL] = (0, smithy_client_1.strictParseLong)(output[_DTTL]);
    }
    if (output[_MTTLa] != null) {
        contents[_MTTLa] = (0, smithy_client_1.strictParseLong)(output[_MTTLa]);
    }
    return contents;
};
const de_CacheBehaviorList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheBehavior(entry, context);
    });
};
const de_CacheBehaviors = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CB] != null) {
        contents[_It] = de_CacheBehaviorList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CB]), context);
    }
    return contents;
};
const de_CachedMethods = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Met] != null) {
        contents[_It] = de_MethodsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Met]), context);
    }
    return contents;
};
const de_CachePolicy = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_CPC] != null) {
        contents[_CPC] = de_CachePolicyConfig(output[_CPC], context);
    }
    return contents;
};
const de_CachePolicyConfig = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_DTTL] != null) {
        contents[_DTTL] = (0, smithy_client_1.strictParseLong)(output[_DTTL]);
    }
    if (output[_MTTLa] != null) {
        contents[_MTTLa] = (0, smithy_client_1.strictParseLong)(output[_MTTLa]);
    }
    if (output[_MTTL] != null) {
        contents[_MTTL] = (0, smithy_client_1.strictParseLong)(output[_MTTL]);
    }
    if (output[_PICKAFTO] != null) {
        contents[_PICKAFTO] = de_ParametersInCacheKeyAndForwardedToOrigin(output[_PICKAFTO], context);
    }
    return contents;
};
const de_CachePolicyCookiesConfig = (output, context) => {
    const contents = {};
    if (output[_CBo] != null) {
        contents[_CBo] = (0, smithy_client_1.expectString)(output[_CBo]);
    }
    if (output[_Coo] != null) {
        contents[_Coo] = de_CookieNames(output[_Coo], context);
    }
    return contents;
};
const de_CachePolicyHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_HB] != null) {
        contents[_HB] = (0, smithy_client_1.expectString)(output[_HB]);
    }
    if (output[_He] != null) {
        contents[_He] = de_Headers(output[_He], context);
    }
    return contents;
};
const de_CachePolicyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CPS] != null) {
        contents[_It] = de_CachePolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CPS]), context);
    }
    return contents;
};
const de_CachePolicyQueryStringsConfig = (output, context) => {
    const contents = {};
    if (output[_QSB] != null) {
        contents[_QSB] = (0, smithy_client_1.expectString)(output[_QSB]);
    }
    if (output[_QS] != null) {
        contents[_QS] = de_QueryStringNames(output[_QS], context);
    }
    return contents;
};
const de_CachePolicySummary = (output, context) => {
    const contents = {};
    if (output[_T] != null) {
        contents[_T] = (0, smithy_client_1.expectString)(output[_T]);
    }
    if (output[_CPa] != null) {
        contents[_CPa] = de_CachePolicy(output[_CPa], context);
    }
    return contents;
};
const de_CachePolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CachePolicySummary(entry, context);
    });
};
const de_CloudFrontOriginAccessIdentity = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_SCUI] != null) {
        contents[_SCUI] = (0, smithy_client_1.expectString)(output[_SCUI]);
    }
    if (output[_CFOAIC] != null) {
        contents[_CFOAIC] = de_CloudFrontOriginAccessIdentityConfig(output[_CFOAIC], context);
    }
    return contents;
};
const de_CloudFrontOriginAccessIdentityConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_CloudFrontOriginAccessIdentityList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CFOAIS] != null) {
        contents[_It] = de_CloudFrontOriginAccessIdentitySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CFOAIS]), context);
    }
    return contents;
};
const de_CloudFrontOriginAccessIdentitySummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_SCUI] != null) {
        contents[_SCUI] = (0, smithy_client_1.expectString)(output[_SCUI]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_CloudFrontOriginAccessIdentitySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CloudFrontOriginAccessIdentitySummary(entry, context);
    });
};
const de_ConflictingAlias = (output, context) => {
    const contents = {};
    if (output[_A] != null) {
        contents[_A] = (0, smithy_client_1.expectString)(output[_A]);
    }
    if (output[_DI] != null) {
        contents[_DI] = (0, smithy_client_1.expectString)(output[_DI]);
    }
    if (output[_AI] != null) {
        contents[_AI] = (0, smithy_client_1.expectString)(output[_AI]);
    }
    return contents;
};
const de_ConflictingAliases = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ConflictingAlias(entry, context);
    });
};
const de_ConflictingAliasesList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CAo] != null) {
        contents[_It] = de_ConflictingAliases((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CAo]), context);
    }
    return contents;
};
const de_ContentTypeProfile = (output, context) => {
    const contents = {};
    if (output[_Fo] != null) {
        contents[_Fo] = (0, smithy_client_1.expectString)(output[_Fo]);
    }
    if (output[_PI] != null) {
        contents[_PI] = (0, smithy_client_1.expectString)(output[_PI]);
    }
    if (output[_CT] != null) {
        contents[_CT] = (0, smithy_client_1.expectString)(output[_CT]);
    }
    return contents;
};
const de_ContentTypeProfileConfig = (output, context) => {
    const contents = {};
    if (output[_FWCTIU] != null) {
        contents[_FWCTIU] = (0, smithy_client_1.parseBoolean)(output[_FWCTIU]);
    }
    if (output[_CTPo] != null) {
        contents[_CTPo] = de_ContentTypeProfiles(output[_CTPo], context);
    }
    return contents;
};
const de_ContentTypeProfileList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ContentTypeProfile(entry, context);
    });
};
const de_ContentTypeProfiles = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CTP] != null) {
        contents[_It] = de_ContentTypeProfileList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CTP]), context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicy = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_CDPC] != null) {
        contents[_CDPC] = de_ContinuousDeploymentPolicyConfig(output[_CDPC], context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicyConfig = (output, context) => {
    const contents = {};
    if (output[_SDDN] != null) {
        contents[_SDDN] = de_StagingDistributionDnsNames(output[_SDDN], context);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_TC] != null) {
        contents[_TC] = de_TrafficConfig(output[_TC], context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CDPS] != null) {
        contents[_It] = de_ContinuousDeploymentPolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CDPS]), context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicySummary = (output, context) => {
    const contents = {};
    if (output[_CDP] != null) {
        contents[_CDP] = de_ContinuousDeploymentPolicy(output[_CDP], context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ContinuousDeploymentPolicySummary(entry, context);
    });
};
const de_ContinuousDeploymentSingleHeaderConfig = (output, context) => {
    const contents = {};
    if (output[_H] != null) {
        contents[_H] = (0, smithy_client_1.expectString)(output[_H]);
    }
    if (output[_V] != null) {
        contents[_V] = (0, smithy_client_1.expectString)(output[_V]);
    }
    return contents;
};
const de_ContinuousDeploymentSingleWeightConfig = (output, context) => {
    const contents = {};
    if (output[_W] != null) {
        contents[_W] = (0, smithy_client_1.strictParseFloat)(output[_W]);
    }
    if (output[_SSC] != null) {
        contents[_SSC] = de_SessionStickinessConfig(output[_SSC], context);
    }
    return contents;
};
const de_CookieNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_CookieNames = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_N] != null) {
        contents[_It] = de_CookieNameList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_N]), context);
    }
    return contents;
};
const de_CookiePreference = (output, context) => {
    const contents = {};
    if (output[_For] != null) {
        contents[_For] = (0, smithy_client_1.expectString)(output[_For]);
    }
    if (output[_WN] != null) {
        contents[_WN] = de_CookieNames(output[_WN], context);
    }
    return contents;
};
const de_CustomErrorResponse = (output, context) => {
    const contents = {};
    if (output[_EC] != null) {
        contents[_EC] = (0, smithy_client_1.strictParseInt32)(output[_EC]);
    }
    if (output[_RPP] != null) {
        contents[_RPP] = (0, smithy_client_1.expectString)(output[_RPP]);
    }
    if (output[_RC] != null) {
        contents[_RC] = (0, smithy_client_1.expectString)(output[_RC]);
    }
    if (output[_ECMTTL] != null) {
        contents[_ECMTTL] = (0, smithy_client_1.strictParseLong)(output[_ECMTTL]);
    }
    return contents;
};
const de_CustomErrorResponseList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CustomErrorResponse(entry, context);
    });
};
const de_CustomErrorResponses = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CER] != null) {
        contents[_It] = de_CustomErrorResponseList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CER]), context);
    }
    return contents;
};
const de_CustomHeaders = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_OCH] != null) {
        contents[_It] = de_OriginCustomHeadersList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_OCH]), context);
    }
    return contents;
};
const de_CustomOriginConfig = (output, context) => {
    const contents = {};
    if (output[_HTTPP] != null) {
        contents[_HTTPP] = (0, smithy_client_1.strictParseInt32)(output[_HTTPP]);
    }
    if (output[_HTTPSP] != null) {
        contents[_HTTPSP] = (0, smithy_client_1.strictParseInt32)(output[_HTTPSP]);
    }
    if (output[_OPP] != null) {
        contents[_OPP] = (0, smithy_client_1.expectString)(output[_OPP]);
    }
    if (output[_OSP] != null) {
        contents[_OSP] = de_OriginSslProtocols(output[_OSP], context);
    }
    if (output[_ORT] != null) {
        contents[_ORT] = (0, smithy_client_1.strictParseInt32)(output[_ORT]);
    }
    if (output[_OKT] != null) {
        contents[_OKT] = (0, smithy_client_1.strictParseInt32)(output[_OKT]);
    }
    return contents;
};
const de_DefaultCacheBehavior = (output, context) => {
    const contents = {};
    if (output[_TOI] != null) {
        contents[_TOI] = (0, smithy_client_1.expectString)(output[_TOI]);
    }
    if (output[_TS] != null) {
        contents[_TS] = de_TrustedSigners(output[_TS], context);
    }
    if (output[_TKG] != null) {
        contents[_TKG] = de_TrustedKeyGroups(output[_TKG], context);
    }
    if (output[_VPP] != null) {
        contents[_VPP] = (0, smithy_client_1.expectString)(output[_VPP]);
    }
    if (output[_AM] != null) {
        contents[_AM] = de_AllowedMethods(output[_AM], context);
    }
    if (output[_SS] != null) {
        contents[_SS] = (0, smithy_client_1.parseBoolean)(output[_SS]);
    }
    if (output[_Co] != null) {
        contents[_Co] = (0, smithy_client_1.parseBoolean)(output[_Co]);
    }
    if (output[_LFA] != null) {
        contents[_LFA] = de_LambdaFunctionAssociations(output[_LFA], context);
    }
    if (output[_FA] != null) {
        contents[_FA] = de_FunctionAssociations(output[_FA], context);
    }
    if (output[_FLEI] != null) {
        contents[_FLEI] = (0, smithy_client_1.expectString)(output[_FLEI]);
    }
    if (output[_RLCA] != null) {
        contents[_RLCA] = (0, smithy_client_1.expectString)(output[_RLCA]);
    }
    if (output[_CPI] != null) {
        contents[_CPI] = (0, smithy_client_1.expectString)(output[_CPI]);
    }
    if (output[_ORPI] != null) {
        contents[_ORPI] = (0, smithy_client_1.expectString)(output[_ORPI]);
    }
    if (output[_RHPI] != null) {
        contents[_RHPI] = (0, smithy_client_1.expectString)(output[_RHPI]);
    }
    if (output[_FV] != null) {
        contents[_FV] = de_ForwardedValues(output[_FV], context);
    }
    if (output[_MTTL] != null) {
        contents[_MTTL] = (0, smithy_client_1.strictParseLong)(output[_MTTL]);
    }
    if (output[_DTTL] != null) {
        contents[_DTTL] = (0, smithy_client_1.strictParseLong)(output[_DTTL]);
    }
    if (output[_MTTLa] != null) {
        contents[_MTTLa] = (0, smithy_client_1.strictParseLong)(output[_MTTLa]);
    }
    return contents;
};
const de_Distribution = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_IPIB] != null) {
        contents[_IPIB] = (0, smithy_client_1.strictParseInt32)(output[_IPIB]);
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_ATS] != null) {
        contents[_ATS] = de_ActiveTrustedSigners(output[_ATS], context);
    }
    if (output[_ATKG] != null) {
        contents[_ATKG] = de_ActiveTrustedKeyGroups(output[_ATKG], context);
    }
    if (output[_DC] != null) {
        contents[_DC] = de_DistributionConfig(output[_DC], context);
    }
    if (output.AliasICPRecordals === "") {
        contents[_AICPR] = [];
    }
    else if (output[_AICPR] != null && output[_AICPR][_AICPRl] != null) {
        contents[_AICPR] = de_AliasICPRecordals((0, smithy_client_1.getArrayIfSingleItem)(output[_AICPR][_AICPRl]), context);
    }
    return contents;
};
const de_DistributionConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_Al] != null) {
        contents[_Al] = de_Aliases(output[_Al], context);
    }
    if (output[_DRO] != null) {
        contents[_DRO] = (0, smithy_client_1.expectString)(output[_DRO]);
    }
    if (output[_Ori] != null) {
        contents[_Ori] = de_Origins(output[_Ori], context);
    }
    if (output[_OG] != null) {
        contents[_OG] = de_OriginGroups(output[_OG], context);
    }
    if (output[_DCB] != null) {
        contents[_DCB] = de_DefaultCacheBehavior(output[_DCB], context);
    }
    if (output[_CBa] != null) {
        contents[_CBa] = de_CacheBehaviors(output[_CBa], context);
    }
    if (output[_CERu] != null) {
        contents[_CERu] = de_CustomErrorResponses(output[_CERu], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_Lo] != null) {
        contents[_Lo] = de_LoggingConfig(output[_Lo], context);
    }
    if (output[_PC] != null) {
        contents[_PC] = (0, smithy_client_1.expectString)(output[_PC]);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_VC] != null) {
        contents[_VC] = de_ViewerCertificate(output[_VC], context);
    }
    if (output[_Re] != null) {
        contents[_Re] = de_Restrictions(output[_Re], context);
    }
    if (output[_WACLI] != null) {
        contents[_WACLI] = (0, smithy_client_1.expectString)(output[_WACLI]);
    }
    if (output[_HV] != null) {
        contents[_HV] = (0, smithy_client_1.expectString)(output[_HV]);
    }
    if (output[_IIPVE] != null) {
        contents[_IIPVE] = (0, smithy_client_1.parseBoolean)(output[_IIPVE]);
    }
    if (output[_CDPI] != null) {
        contents[_CDPI] = (0, smithy_client_1.expectString)(output[_CDPI]);
    }
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.parseBoolean)(output[_S]);
    }
    return contents;
};
const de_DistributionIdList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_DI] != null) {
        contents[_It] = de_DistributionIdListSummary((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_DI]), context);
    }
    return contents;
};
const de_DistributionIdListSummary = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_DistributionList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_DS] != null) {
        contents[_It] = de_DistributionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_DS]), context);
    }
    return contents;
};
const de_DistributionSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_Al] != null) {
        contents[_Al] = de_Aliases(output[_Al], context);
    }
    if (output[_Ori] != null) {
        contents[_Ori] = de_Origins(output[_Ori], context);
    }
    if (output[_OG] != null) {
        contents[_OG] = de_OriginGroups(output[_OG], context);
    }
    if (output[_DCB] != null) {
        contents[_DCB] = de_DefaultCacheBehavior(output[_DCB], context);
    }
    if (output[_CBa] != null) {
        contents[_CBa] = de_CacheBehaviors(output[_CBa], context);
    }
    if (output[_CERu] != null) {
        contents[_CERu] = de_CustomErrorResponses(output[_CERu], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_PC] != null) {
        contents[_PC] = (0, smithy_client_1.expectString)(output[_PC]);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_VC] != null) {
        contents[_VC] = de_ViewerCertificate(output[_VC], context);
    }
    if (output[_Re] != null) {
        contents[_Re] = de_Restrictions(output[_Re], context);
    }
    if (output[_WACLI] != null) {
        contents[_WACLI] = (0, smithy_client_1.expectString)(output[_WACLI]);
    }
    if (output[_HV] != null) {
        contents[_HV] = (0, smithy_client_1.expectString)(output[_HV]);
    }
    if (output[_IIPVE] != null) {
        contents[_IIPVE] = (0, smithy_client_1.parseBoolean)(output[_IIPVE]);
    }
    if (output.AliasICPRecordals === "") {
        contents[_AICPR] = [];
    }
    else if (output[_AICPR] != null && output[_AICPR][_AICPRl] != null) {
        contents[_AICPR] = de_AliasICPRecordals((0, smithy_client_1.getArrayIfSingleItem)(output[_AICPR][_AICPRl]), context);
    }
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.parseBoolean)(output[_S]);
    }
    return contents;
};
const de_DistributionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DistributionSummary(entry, context);
    });
};
const de_EncryptionEntities = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_EEn] != null) {
        contents[_It] = de_EncryptionEntityList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_EEn]), context);
    }
    return contents;
};
const de_EncryptionEntity = (output, context) => {
    const contents = {};
    if (output[_PKI] != null) {
        contents[_PKI] = (0, smithy_client_1.expectString)(output[_PKI]);
    }
    if (output[_PIr] != null) {
        contents[_PIr] = (0, smithy_client_1.expectString)(output[_PIr]);
    }
    if (output[_FP] != null) {
        contents[_FP] = de_FieldPatterns(output[_FP], context);
    }
    return contents;
};
const de_EncryptionEntityList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EncryptionEntity(entry, context);
    });
};
const de_EndPoint = (output, context) => {
    const contents = {};
    if (output[_ST] != null) {
        contents[_ST] = (0, smithy_client_1.expectString)(output[_ST]);
    }
    if (output[_KSC] != null) {
        contents[_KSC] = de_KinesisStreamConfig(output[_KSC], context);
    }
    return contents;
};
const de_EndPointList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EndPoint(entry, context);
    });
};
const de_FieldLevelEncryption = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_FLEC] != null) {
        contents[_FLEC] = de_FieldLevelEncryptionConfig(output[_FLEC], context);
    }
    return contents;
};
const de_FieldLevelEncryptionConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_QAPC] != null) {
        contents[_QAPC] = de_QueryArgProfileConfig(output[_QAPC], context);
    }
    if (output[_CTPC] != null) {
        contents[_CTPC] = de_ContentTypeProfileConfig(output[_CTPC], context);
    }
    return contents;
};
const de_FieldLevelEncryptionList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FLES] != null) {
        contents[_It] = de_FieldLevelEncryptionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FLES]), context);
    }
    return contents;
};
const de_FieldLevelEncryptionProfile = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_FLEPC] != null) {
        contents[_FLEPC] = de_FieldLevelEncryptionProfileConfig(output[_FLEPC], context);
    }
    return contents;
};
const de_FieldLevelEncryptionProfileConfig = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_EE] != null) {
        contents[_EE] = de_EncryptionEntities(output[_EE], context);
    }
    return contents;
};
const de_FieldLevelEncryptionProfileList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FLEPS] != null) {
        contents[_It] = de_FieldLevelEncryptionProfileSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FLEPS]), context);
    }
    return contents;
};
const de_FieldLevelEncryptionProfileSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_EE] != null) {
        contents[_EE] = de_EncryptionEntities(output[_EE], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_FieldLevelEncryptionProfileSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FieldLevelEncryptionProfileSummary(entry, context);
    });
};
const de_FieldLevelEncryptionSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_QAPC] != null) {
        contents[_QAPC] = de_QueryArgProfileConfig(output[_QAPC], context);
    }
    if (output[_CTPC] != null) {
        contents[_CTPC] = de_ContentTypeProfileConfig(output[_CTPC], context);
    }
    return contents;
};
const de_FieldLevelEncryptionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FieldLevelEncryptionSummary(entry, context);
    });
};
const de_FieldList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_FieldPatternList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_FieldPatterns = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FPi] != null) {
        contents[_It] = de_FieldPatternList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FPi]), context);
    }
    return contents;
};
const de_ForwardedValues = (output, context) => {
    const contents = {};
    if (output[_QSu] != null) {
        contents[_QSu] = (0, smithy_client_1.parseBoolean)(output[_QSu]);
    }
    if (output[_Coo] != null) {
        contents[_Coo] = de_CookiePreference(output[_Coo], context);
    }
    if (output[_He] != null) {
        contents[_He] = de_Headers(output[_He], context);
    }
    if (output[_QSCK] != null) {
        contents[_QSCK] = de_QueryStringCacheKeys(output[_QSCK], context);
    }
    return contents;
};
const de_FunctionAssociation = (output, context) => {
    const contents = {};
    if (output[_FARN] != null) {
        contents[_FARN] = (0, smithy_client_1.expectString)(output[_FARN]);
    }
    if (output[_ETv] != null) {
        contents[_ETv] = (0, smithy_client_1.expectString)(output[_ETv]);
    }
    return contents;
};
const de_FunctionAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FunctionAssociation(entry, context);
    });
};
const de_FunctionAssociations = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FAu] != null) {
        contents[_It] = de_FunctionAssociationList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FAu]), context);
    }
    return contents;
};
const de_FunctionConfig = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_Ru] != null) {
        contents[_Ru] = (0, smithy_client_1.expectString)(output[_Ru]);
    }
    if (output[_KVSA] != null) {
        contents[_KVSA] = de_KeyValueStoreAssociations(output[_KVSA], context);
    }
    return contents;
};
const de_FunctionExecutionLogList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_FunctionList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FSu] != null) {
        contents[_It] = de_FunctionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FSu]), context);
    }
    return contents;
};
const de_FunctionMetadata = (output, context) => {
    const contents = {};
    if (output[_FARN] != null) {
        contents[_FARN] = (0, smithy_client_1.expectString)(output[_FARN]);
    }
    if (output[_St] != null) {
        contents[_St] = (0, smithy_client_1.expectString)(output[_St]);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTr]));
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    return contents;
};
const de_FunctionSummary = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_FCu] != null) {
        contents[_FCu] = de_FunctionConfig(output[_FCu], context);
    }
    if (output[_FM] != null) {
        contents[_FM] = de_FunctionMetadata(output[_FM], context);
    }
    return contents;
};
const de_FunctionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FunctionSummary(entry, context);
    });
};
const de_GeoRestriction = (output, context) => {
    const contents = {};
    if (output[_RT] != null) {
        contents[_RT] = (0, smithy_client_1.expectString)(output[_RT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_L] != null) {
        contents[_It] = de_LocationList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_L]), context);
    }
    return contents;
};
const de_HeaderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_Headers = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_N] != null) {
        contents[_It] = de_HeaderList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_N]), context);
    }
    return contents;
};
const de_Invalidation = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_CTre] != null) {
        contents[_CTre] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTre]));
    }
    if (output[_IB] != null) {
        contents[_IB] = de_InvalidationBatch(output[_IB], context);
    }
    return contents;
};
const de_InvalidationBatch = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = de_Paths(output[_P], context);
    }
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    return contents;
};
const de_InvalidationList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_ISnv] != null) {
        contents[_It] = de_InvalidationSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_ISnv]), context);
    }
    return contents;
};
const de_InvalidationSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_CTre] != null) {
        contents[_CTre] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTre]));
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    return contents;
};
const de_InvalidationSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InvalidationSummary(entry, context);
    });
};
const de_KeyGroup = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_KGC] != null) {
        contents[_KGC] = de_KeyGroupConfig(output[_KGC], context);
    }
    return contents;
};
const de_KeyGroupConfig = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_PK] != null) {
        contents[_It] = de_PublicKeyIdList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_PK]), context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_KeyGroupList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KGS] != null) {
        contents[_It] = de_KeyGroupSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KGS]), context);
    }
    return contents;
};
const de_KeyGroupSummary = (output, context) => {
    const contents = {};
    if (output[_KG] != null) {
        contents[_KG] = de_KeyGroup(output[_KG], context);
    }
    return contents;
};
const de_KeyGroupSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KeyGroupSummary(entry, context);
    });
};
const de_KeyPairIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_KeyPairIds = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KPI] != null) {
        contents[_It] = de_KeyPairIdList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KPI]), context);
    }
    return contents;
};
const de_KeyValueStore = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    return contents;
};
const de_KeyValueStoreAssociation = (output, context) => {
    const contents = {};
    if (output[_KVSARN] != null) {
        contents[_KVSARN] = (0, smithy_client_1.expectString)(output[_KVSARN]);
    }
    return contents;
};
const de_KeyValueStoreAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KeyValueStoreAssociation(entry, context);
    });
};
const de_KeyValueStoreAssociations = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KVSAe] != null) {
        contents[_It] = de_KeyValueStoreAssociationList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KVSAe]), context);
    }
    return contents;
};
const de_KeyValueStoreList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KVS] != null) {
        contents[_It] = de_KeyValueStoreSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KVS]), context);
    }
    return contents;
};
const de_KeyValueStoreSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KeyValueStore(entry, context);
    });
};
const de_KGKeyPairIds = (output, context) => {
    const contents = {};
    if (output[_KGI] != null) {
        contents[_KGI] = (0, smithy_client_1.expectString)(output[_KGI]);
    }
    if (output[_KPIe] != null) {
        contents[_KPIe] = de_KeyPairIds(output[_KPIe], context);
    }
    return contents;
};
const de_KGKeyPairIdsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KGKeyPairIds(entry, context);
    });
};
const de_KinesisStreamConfig = (output, context) => {
    const contents = {};
    if (output[_RARN] != null) {
        contents[_RARN] = (0, smithy_client_1.expectString)(output[_RARN]);
    }
    if (output[_SARNt] != null) {
        contents[_SARNt] = (0, smithy_client_1.expectString)(output[_SARNt]);
    }
    return contents;
};
const de_LambdaFunctionAssociation = (output, context) => {
    const contents = {};
    if (output[_LFARN] != null) {
        contents[_LFARN] = (0, smithy_client_1.expectString)(output[_LFARN]);
    }
    if (output[_ETv] != null) {
        contents[_ETv] = (0, smithy_client_1.expectString)(output[_ETv]);
    }
    if (output[_IBn] != null) {
        contents[_IBn] = (0, smithy_client_1.parseBoolean)(output[_IBn]);
    }
    return contents;
};
const de_LambdaFunctionAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LambdaFunctionAssociation(entry, context);
    });
};
const de_LambdaFunctionAssociations = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_LFAa] != null) {
        contents[_It] = de_LambdaFunctionAssociationList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_LFAa]), context);
    }
    return contents;
};
const de_LocationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_LoggingConfig = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_IC] != null) {
        contents[_IC] = (0, smithy_client_1.parseBoolean)(output[_IC]);
    }
    if (output[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(output[_B]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = (0, smithy_client_1.expectString)(output[_Pr]);
    }
    return contents;
};
const de_MethodsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_MonitoringSubscription = (output, context) => {
    const contents = {};
    if (output[_RMSC] != null) {
        contents[_RMSC] = de_RealtimeMetricsSubscriptionConfig(output[_RMSC], context);
    }
    return contents;
};
const de_Origin = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_OP] != null) {
        contents[_OP] = (0, smithy_client_1.expectString)(output[_OP]);
    }
    if (output[_CH] != null) {
        contents[_CH] = de_CustomHeaders(output[_CH], context);
    }
    if (output[_SOC] != null) {
        contents[_SOC] = de_S3OriginConfig(output[_SOC], context);
    }
    if (output[_COC] != null) {
        contents[_COC] = de_CustomOriginConfig(output[_COC], context);
    }
    if (output[_CA] != null) {
        contents[_CA] = (0, smithy_client_1.strictParseInt32)(output[_CA]);
    }
    if (output[_CTon] != null) {
        contents[_CTon] = (0, smithy_client_1.strictParseInt32)(output[_CTon]);
    }
    if (output[_OS] != null) {
        contents[_OS] = de_OriginShield(output[_OS], context);
    }
    if (output[_OACI] != null) {
        contents[_OACI] = (0, smithy_client_1.expectString)(output[_OACI]);
    }
    return contents;
};
const de_OriginAccessControl = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_OACC] != null) {
        contents[_OACC] = de_OriginAccessControlConfig(output[_OACC], context);
    }
    return contents;
};
const de_OriginAccessControlConfig = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_D] != null) {
        contents[_D] = (0, smithy_client_1.expectString)(output[_D]);
    }
    if (output[_SP] != null) {
        contents[_SP] = (0, smithy_client_1.expectString)(output[_SP]);
    }
    if (output[_SB] != null) {
        contents[_SB] = (0, smithy_client_1.expectString)(output[_SB]);
    }
    if (output[_OACOT] != null) {
        contents[_OACOT] = (0, smithy_client_1.expectString)(output[_OACOT]);
    }
    return contents;
};
const de_OriginAccessControlList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_OACS] != null) {
        contents[_It] = de_OriginAccessControlSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_OACS]), context);
    }
    return contents;
};
const de_OriginAccessControlSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_D] != null) {
        contents[_D] = (0, smithy_client_1.expectString)(output[_D]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_SP] != null) {
        contents[_SP] = (0, smithy_client_1.expectString)(output[_SP]);
    }
    if (output[_SB] != null) {
        contents[_SB] = (0, smithy_client_1.expectString)(output[_SB]);
    }
    if (output[_OACOT] != null) {
        contents[_OACOT] = (0, smithy_client_1.expectString)(output[_OACOT]);
    }
    return contents;
};
const de_OriginAccessControlSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginAccessControlSummary(entry, context);
    });
};
const de_OriginCustomHeader = (output, context) => {
    const contents = {};
    if (output[_HN] != null) {
        contents[_HN] = (0, smithy_client_1.expectString)(output[_HN]);
    }
    if (output[_HVe] != null) {
        contents[_HVe] = (0, smithy_client_1.expectString)(output[_HVe]);
    }
    return contents;
};
const de_OriginCustomHeadersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginCustomHeader(entry, context);
    });
};
const de_OriginGroup = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_FCa] != null) {
        contents[_FCa] = de_OriginGroupFailoverCriteria(output[_FCa], context);
    }
    if (output[_Mem] != null) {
        contents[_Mem] = de_OriginGroupMembers(output[_Mem], context);
    }
    return contents;
};
const de_OriginGroupFailoverCriteria = (output, context) => {
    const contents = {};
    if (output[_SC] != null) {
        contents[_SC] = de_StatusCodes(output[_SC], context);
    }
    return contents;
};
const de_OriginGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginGroup(entry, context);
    });
};
const de_OriginGroupMember = (output, context) => {
    const contents = {};
    if (output[_OI] != null) {
        contents[_OI] = (0, smithy_client_1.expectString)(output[_OI]);
    }
    return contents;
};
const de_OriginGroupMemberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginGroupMember(entry, context);
    });
};
const de_OriginGroupMembers = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_OGM] != null) {
        contents[_It] = de_OriginGroupMemberList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_OGM]), context);
    }
    return contents;
};
const de_OriginGroups = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_OGr] != null) {
        contents[_It] = de_OriginGroupList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_OGr]), context);
    }
    return contents;
};
const de_OriginList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Origin(entry, context);
    });
};
const de_OriginRequestPolicy = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_ORPC] != null) {
        contents[_ORPC] = de_OriginRequestPolicyConfig(output[_ORPC], context);
    }
    return contents;
};
const de_OriginRequestPolicyConfig = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_HC] != null) {
        contents[_HC] = de_OriginRequestPolicyHeadersConfig(output[_HC], context);
    }
    if (output[_CC] != null) {
        contents[_CC] = de_OriginRequestPolicyCookiesConfig(output[_CC], context);
    }
    if (output[_QSC] != null) {
        contents[_QSC] = de_OriginRequestPolicyQueryStringsConfig(output[_QSC], context);
    }
    return contents;
};
const de_OriginRequestPolicyCookiesConfig = (output, context) => {
    const contents = {};
    if (output[_CBo] != null) {
        contents[_CBo] = (0, smithy_client_1.expectString)(output[_CBo]);
    }
    if (output[_Coo] != null) {
        contents[_Coo] = de_CookieNames(output[_Coo], context);
    }
    return contents;
};
const de_OriginRequestPolicyHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_HB] != null) {
        contents[_HB] = (0, smithy_client_1.expectString)(output[_HB]);
    }
    if (output[_He] != null) {
        contents[_He] = de_Headers(output[_He], context);
    }
    return contents;
};
const de_OriginRequestPolicyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_ORPS] != null) {
        contents[_It] = de_OriginRequestPolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_ORPS]), context);
    }
    return contents;
};
const de_OriginRequestPolicyQueryStringsConfig = (output, context) => {
    const contents = {};
    if (output[_QSB] != null) {
        contents[_QSB] = (0, smithy_client_1.expectString)(output[_QSB]);
    }
    if (output[_QS] != null) {
        contents[_QS] = de_QueryStringNames(output[_QS], context);
    }
    return contents;
};
const de_OriginRequestPolicySummary = (output, context) => {
    const contents = {};
    if (output[_T] != null) {
        contents[_T] = (0, smithy_client_1.expectString)(output[_T]);
    }
    if (output[_ORP] != null) {
        contents[_ORP] = de_OriginRequestPolicy(output[_ORP], context);
    }
    return contents;
};
const de_OriginRequestPolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginRequestPolicySummary(entry, context);
    });
};
const de_Origins = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Or] != null) {
        contents[_It] = de_OriginList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Or]), context);
    }
    return contents;
};
const de_OriginShield = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_OSR] != null) {
        contents[_OSR] = (0, smithy_client_1.expectString)(output[_OSR]);
    }
    return contents;
};
const de_OriginSslProtocols = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_SPs] != null) {
        contents[_It] = de_SslProtocolsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_SPs]), context);
    }
    return contents;
};
const de_ParametersInCacheKeyAndForwardedToOrigin = (output, context) => {
    const contents = {};
    if (output[_EAEG] != null) {
        contents[_EAEG] = (0, smithy_client_1.parseBoolean)(output[_EAEG]);
    }
    if (output[_EAEB] != null) {
        contents[_EAEB] = (0, smithy_client_1.parseBoolean)(output[_EAEB]);
    }
    if (output[_HC] != null) {
        contents[_HC] = de_CachePolicyHeadersConfig(output[_HC], context);
    }
    if (output[_CC] != null) {
        contents[_CC] = de_CachePolicyCookiesConfig(output[_CC], context);
    }
    if (output[_QSC] != null) {
        contents[_QSC] = de_CachePolicyQueryStringsConfig(output[_QSC], context);
    }
    return contents;
};
const de_PathList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_Paths = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Pa] != null) {
        contents[_It] = de_PathList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Pa]), context);
    }
    return contents;
};
const de_PublicKey = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTr]));
    }
    if (output[_PKC] != null) {
        contents[_PKC] = de_PublicKeyConfig(output[_PKC], context);
    }
    return contents;
};
const de_PublicKeyConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_EK] != null) {
        contents[_EK] = (0, smithy_client_1.expectString)(output[_EK]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_PublicKeyIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_PublicKeyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_PKS] != null) {
        contents[_It] = de_PublicKeySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_PKS]), context);
    }
    return contents;
};
const de_PublicKeySummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTr]));
    }
    if (output[_EK] != null) {
        contents[_EK] = (0, smithy_client_1.expectString)(output[_EK]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_PublicKeySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PublicKeySummary(entry, context);
    });
};
const de_QueryArgProfile = (output, context) => {
    const contents = {};
    if (output[_QA] != null) {
        contents[_QA] = (0, smithy_client_1.expectString)(output[_QA]);
    }
    if (output[_PI] != null) {
        contents[_PI] = (0, smithy_client_1.expectString)(output[_PI]);
    }
    return contents;
};
const de_QueryArgProfileConfig = (output, context) => {
    const contents = {};
    if (output[_FWQAPIU] != null) {
        contents[_FWQAPIU] = (0, smithy_client_1.parseBoolean)(output[_FWQAPIU]);
    }
    if (output[_QAPu] != null) {
        contents[_QAPu] = de_QueryArgProfiles(output[_QAPu], context);
    }
    return contents;
};
const de_QueryArgProfileList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_QueryArgProfile(entry, context);
    });
};
const de_QueryArgProfiles = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_QAP] != null) {
        contents[_It] = de_QueryArgProfileList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_QAP]), context);
    }
    return contents;
};
const de_QueryStringCacheKeys = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_N] != null) {
        contents[_It] = de_QueryStringCacheKeysList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_N]), context);
    }
    return contents;
};
const de_QueryStringCacheKeysList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_QueryStringNames = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_N] != null) {
        contents[_It] = de_QueryStringNamesList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_N]), context);
    }
    return contents;
};
const de_QueryStringNamesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_RealtimeLogConfig = (output, context) => {
    const contents = {};
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_SR] != null) {
        contents[_SR] = (0, smithy_client_1.strictParseLong)(output[_SR]);
    }
    if (output.EndPoints === "") {
        contents[_EP] = [];
    }
    else if (output[_EP] != null && output[_EP][_m] != null) {
        contents[_EP] = de_EndPointList((0, smithy_client_1.getArrayIfSingleItem)(output[_EP][_m]), context);
    }
    if (output.Fields === "") {
        contents[_F] = [];
    }
    else if (output[_F] != null && output[_F][_Fi] != null) {
        contents[_F] = de_FieldList((0, smithy_client_1.getArrayIfSingleItem)(output[_F][_Fi]), context);
    }
    return contents;
};
const de_RealtimeLogConfigList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RealtimeLogConfig(entry, context);
    });
};
const de_RealtimeLogConfigs = (output, context) => {
    const contents = {};
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_m] != null) {
        contents[_It] = de_RealtimeLogConfigList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_m]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    return contents;
};
const de_RealtimeMetricsSubscriptionConfig = (output, context) => {
    const contents = {};
    if (output[_RMSS] != null) {
        contents[_RMSS] = (0, smithy_client_1.expectString)(output[_RMSS]);
    }
    return contents;
};
const de_ResponseHeadersPolicy = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_RHPC] != null) {
        contents[_RHPC] = de_ResponseHeadersPolicyConfig(output[_RHPC], context);
    }
    return contents;
};
const de_ResponseHeadersPolicyAccessControlAllowHeaders = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_H] != null) {
        contents[_It] = de_AccessControlAllowHeadersList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_H]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyAccessControlAllowMethods = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Met] != null) {
        contents[_It] = de_AccessControlAllowMethodsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Met]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyAccessControlAllowOrigins = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Or] != null) {
        contents[_It] = de_AccessControlAllowOriginsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Or]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyAccessControlExposeHeaders = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_H] != null) {
        contents[_It] = de_AccessControlExposeHeadersList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_H]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyConfig = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_CCo] != null) {
        contents[_CCo] = de_ResponseHeadersPolicyCorsConfig(output[_CCo], context);
    }
    if (output[_SHC] != null) {
        contents[_SHC] = de_ResponseHeadersPolicySecurityHeadersConfig(output[_SHC], context);
    }
    if (output[_STHC] != null) {
        contents[_STHC] = de_ResponseHeadersPolicyServerTimingHeadersConfig(output[_STHC], context);
    }
    if (output[_CHC] != null) {
        contents[_CHC] = de_ResponseHeadersPolicyCustomHeadersConfig(output[_CHC], context);
    }
    if (output[_RHC] != null) {
        contents[_RHC] = de_ResponseHeadersPolicyRemoveHeadersConfig(output[_RHC], context);
    }
    return contents;
};
const de_ResponseHeadersPolicyContentSecurityPolicy = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_CSP] != null) {
        contents[_CSP] = (0, smithy_client_1.expectString)(output[_CSP]);
    }
    return contents;
};
const de_ResponseHeadersPolicyContentTypeOptions = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    return contents;
};
const de_ResponseHeadersPolicyCorsConfig = (output, context) => {
    const contents = {};
    if (output[_ACAO] != null) {
        contents[_ACAO] = de_ResponseHeadersPolicyAccessControlAllowOrigins(output[_ACAO], context);
    }
    if (output[_ACAH] != null) {
        contents[_ACAH] = de_ResponseHeadersPolicyAccessControlAllowHeaders(output[_ACAH], context);
    }
    if (output[_ACAM] != null) {
        contents[_ACAM] = de_ResponseHeadersPolicyAccessControlAllowMethods(output[_ACAM], context);
    }
    if (output[_ACAC] != null) {
        contents[_ACAC] = (0, smithy_client_1.parseBoolean)(output[_ACAC]);
    }
    if (output[_ACEH] != null) {
        contents[_ACEH] = de_ResponseHeadersPolicyAccessControlExposeHeaders(output[_ACEH], context);
    }
    if (output[_ACMAS] != null) {
        contents[_ACMAS] = (0, smithy_client_1.strictParseInt32)(output[_ACMAS]);
    }
    if (output[_OO] != null) {
        contents[_OO] = (0, smithy_client_1.parseBoolean)(output[_OO]);
    }
    return contents;
};
const de_ResponseHeadersPolicyCustomHeader = (output, context) => {
    const contents = {};
    if (output[_H] != null) {
        contents[_H] = (0, smithy_client_1.expectString)(output[_H]);
    }
    if (output[_V] != null) {
        contents[_V] = (0, smithy_client_1.expectString)(output[_V]);
    }
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    return contents;
};
const de_ResponseHeadersPolicyCustomHeaderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseHeadersPolicyCustomHeader(entry, context);
    });
};
const de_ResponseHeadersPolicyCustomHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_RHPCH] != null) {
        contents[_It] = de_ResponseHeadersPolicyCustomHeaderList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_RHPCH]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyFrameOptions = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_FO] != null) {
        contents[_FO] = (0, smithy_client_1.expectString)(output[_FO]);
    }
    return contents;
};
const de_ResponseHeadersPolicyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_RHPS] != null) {
        contents[_It] = de_ResponseHeadersPolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_RHPS]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyReferrerPolicy = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_RP] != null) {
        contents[_RP] = (0, smithy_client_1.expectString)(output[_RP]);
    }
    return contents;
};
const de_ResponseHeadersPolicyRemoveHeader = (output, context) => {
    const contents = {};
    if (output[_H] != null) {
        contents[_H] = (0, smithy_client_1.expectString)(output[_H]);
    }
    return contents;
};
const de_ResponseHeadersPolicyRemoveHeaderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseHeadersPolicyRemoveHeader(entry, context);
    });
};
const de_ResponseHeadersPolicyRemoveHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_RHPRH] != null) {
        contents[_It] = de_ResponseHeadersPolicyRemoveHeaderList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_RHPRH]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicySecurityHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_XSSP] != null) {
        contents[_XSSP] = de_ResponseHeadersPolicyXSSProtection(output[_XSSP], context);
    }
    if (output[_FOr] != null) {
        contents[_FOr] = de_ResponseHeadersPolicyFrameOptions(output[_FOr], context);
    }
    if (output[_RP] != null) {
        contents[_RP] = de_ResponseHeadersPolicyReferrerPolicy(output[_RP], context);
    }
    if (output[_CSP] != null) {
        contents[_CSP] = de_ResponseHeadersPolicyContentSecurityPolicy(output[_CSP], context);
    }
    if (output[_CTO] != null) {
        contents[_CTO] = de_ResponseHeadersPolicyContentTypeOptions(output[_CTO], context);
    }
    if (output[_STS] != null) {
        contents[_STS] = de_ResponseHeadersPolicyStrictTransportSecurity(output[_STS], context);
    }
    return contents;
};
const de_ResponseHeadersPolicyServerTimingHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_SR] != null) {
        contents[_SR] = (0, smithy_client_1.strictParseFloat)(output[_SR]);
    }
    return contents;
};
const de_ResponseHeadersPolicyStrictTransportSecurity = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_ISn] != null) {
        contents[_ISn] = (0, smithy_client_1.parseBoolean)(output[_ISn]);
    }
    if (output[_Pre] != null) {
        contents[_Pre] = (0, smithy_client_1.parseBoolean)(output[_Pre]);
    }
    if (output[_ACMAS] != null) {
        contents[_ACMAS] = (0, smithy_client_1.strictParseInt32)(output[_ACMAS]);
    }
    return contents;
};
const de_ResponseHeadersPolicySummary = (output, context) => {
    const contents = {};
    if (output[_T] != null) {
        contents[_T] = (0, smithy_client_1.expectString)(output[_T]);
    }
    if (output[_RHP] != null) {
        contents[_RHP] = de_ResponseHeadersPolicy(output[_RHP], context);
    }
    return contents;
};
const de_ResponseHeadersPolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseHeadersPolicySummary(entry, context);
    });
};
const de_ResponseHeadersPolicyXSSProtection = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_Pro] != null) {
        contents[_Pro] = (0, smithy_client_1.parseBoolean)(output[_Pro]);
    }
    if (output[_MB] != null) {
        contents[_MB] = (0, smithy_client_1.parseBoolean)(output[_MB]);
    }
    if (output[_RU] != null) {
        contents[_RU] = (0, smithy_client_1.expectString)(output[_RU]);
    }
    return contents;
};
const de_Restrictions = (output, context) => {
    const contents = {};
    if (output[_GR] != null) {
        contents[_GR] = de_GeoRestriction(output[_GR], context);
    }
    return contents;
};
const de_S3Origin = (output, context) => {
    const contents = {};
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_OAI] != null) {
        contents[_OAI] = (0, smithy_client_1.expectString)(output[_OAI]);
    }
    return contents;
};
const de_S3OriginConfig = (output, context) => {
    const contents = {};
    if (output[_OAI] != null) {
        contents[_OAI] = (0, smithy_client_1.expectString)(output[_OAI]);
    }
    return contents;
};
const de_SessionStickinessConfig = (output, context) => {
    const contents = {};
    if (output[_ITTL] != null) {
        contents[_ITTL] = (0, smithy_client_1.strictParseInt32)(output[_ITTL]);
    }
    if (output[_MTTLax] != null) {
        contents[_MTTLax] = (0, smithy_client_1.strictParseInt32)(output[_MTTLax]);
    }
    return contents;
};
const de_Signer = (output, context) => {
    const contents = {};
    if (output[_AAN] != null) {
        contents[_AAN] = (0, smithy_client_1.expectString)(output[_AAN]);
    }
    if (output[_KPIe] != null) {
        contents[_KPIe] = de_KeyPairIds(output[_KPIe], context);
    }
    return contents;
};
const de_SignerList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Signer(entry, context);
    });
};
const de_SslProtocolsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_StagingDistributionDnsNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_StagingDistributionDnsNames = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_DNn] != null) {
        contents[_It] = de_StagingDistributionDnsNameList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_DNn]), context);
    }
    return contents;
};
const de_StatusCodeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.strictParseInt32)(entry);
    });
};
const de_StatusCodes = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_SCt] != null) {
        contents[_It] = de_StatusCodeList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_SCt]), context);
    }
    return contents;
};
const de_StreamingDistribution = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_ATS] != null) {
        contents[_ATS] = de_ActiveTrustedSigners(output[_ATS], context);
    }
    if (output[_SDC] != null) {
        contents[_SDC] = de_StreamingDistributionConfig(output[_SDC], context);
    }
    return contents;
};
const de_StreamingDistributionConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_SO] != null) {
        contents[_SO] = de_S3Origin(output[_SO], context);
    }
    if (output[_Al] != null) {
        contents[_Al] = de_Aliases(output[_Al], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_Lo] != null) {
        contents[_Lo] = de_StreamingLoggingConfig(output[_Lo], context);
    }
    if (output[_TS] != null) {
        contents[_TS] = de_TrustedSigners(output[_TS], context);
    }
    if (output[_PC] != null) {
        contents[_PC] = (0, smithy_client_1.expectString)(output[_PC]);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    return contents;
};
const de_StreamingDistributionList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_SDS] != null) {
        contents[_It] = de_StreamingDistributionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_SDS]), context);
    }
    return contents;
};
const de_StreamingDistributionSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_SO] != null) {
        contents[_SO] = de_S3Origin(output[_SO], context);
    }
    if (output[_Al] != null) {
        contents[_Al] = de_Aliases(output[_Al], context);
    }
    if (output[_TS] != null) {
        contents[_TS] = de_TrustedSigners(output[_TS], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_PC] != null) {
        contents[_PC] = (0, smithy_client_1.expectString)(output[_PC]);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    return contents;
};
const de_StreamingDistributionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StreamingDistributionSummary(entry, context);
    });
};
const de_StreamingLoggingConfig = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(output[_B]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = (0, smithy_client_1.expectString)(output[_Pr]);
    }
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    if (output[_V] != null) {
        contents[_V] = (0, smithy_client_1.expectString)(output[_V]);
    }
    return contents;
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_Tags = (output, context) => {
    const contents = {};
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Tag] != null) {
        contents[_It] = de_TagList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Tag]), context);
    }
    return contents;
};
const de_TestResult = (output, context) => {
    const contents = {};
    if (output[_FSu] != null) {
        contents[_FSu] = de_FunctionSummary(output[_FSu], context);
    }
    if (output[_CU] != null) {
        contents[_CU] = (0, smithy_client_1.expectString)(output[_CU]);
    }
    if (output.FunctionExecutionLogs === "") {
        contents[_FEL] = [];
    }
    else if (output[_FEL] != null && output[_FEL][_m] != null) {
        contents[_FEL] = de_FunctionExecutionLogList((0, smithy_client_1.getArrayIfSingleItem)(output[_FEL][_m]), context);
    }
    if (output[_FEM] != null) {
        contents[_FEM] = (0, smithy_client_1.expectString)(output[_FEM]);
    }
    if (output[_FOu] != null) {
        contents[_FOu] = (0, smithy_client_1.expectString)(output[_FOu]);
    }
    return contents;
};
const de_TrafficConfig = (output, context) => {
    const contents = {};
    if (output[_SWC] != null) {
        contents[_SWC] = de_ContinuousDeploymentSingleWeightConfig(output[_SWC], context);
    }
    if (output[_SHCi] != null) {
        contents[_SHCi] = de_ContinuousDeploymentSingleHeaderConfig(output[_SHCi], context);
    }
    if (output[_T] != null) {
        contents[_T] = (0, smithy_client_1.expectString)(output[_T]);
    }
    return contents;
};
const de_TrustedKeyGroupIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_TrustedKeyGroups = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KG] != null) {
        contents[_It] = de_TrustedKeyGroupIdList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KG]), context);
    }
    return contents;
};
const de_TrustedSigners = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_AAN] != null) {
        contents[_It] = de_AwsAccountNumberList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_AAN]), context);
    }
    return contents;
};
const de_ViewerCertificate = (output, context) => {
    const contents = {};
    if (output[_CFDC] != null) {
        contents[_CFDC] = (0, smithy_client_1.parseBoolean)(output[_CFDC]);
    }
    if (output[_IAMCI] != null) {
        contents[_IAMCI] = (0, smithy_client_1.expectString)(output[_IAMCI]);
    }
    if (output[_ACMCA] != null) {
        contents[_ACMCA] = (0, smithy_client_1.expectString)(output[_ACMCA]);
    }
    if (output[_SSLSM] != null) {
        contents[_SSLSM] = (0, smithy_client_1.expectString)(output[_SSLSM]);
    }
    if (output[_MPV] != null) {
        contents[_MPV] = (0, smithy_client_1.expectString)(output[_MPV]);
    }
    if (output[_Ce] != null) {
        contents[_Ce] = (0, smithy_client_1.expectString)(output[_Ce]);
    }
    if (output[_CS] != null) {
        contents[_CS] = (0, smithy_client_1.expectString)(output[_CS]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _A = "Alias";
const _AAN = "AwsAccountNumber";
const _ACAC = "AccessControlAllowCredentials";
const _ACAH = "AccessControlAllowHeaders";
const _ACAM = "AccessControlAllowMethods";
const _ACAO = "AccessControlAllowOrigins";
const _ACEH = "AccessControlExposeHeaders";
const _ACMAS = "AccessControlMaxAgeSec";
const _ACMCA = "ACMCertificateArn";
const _AI = "AccountId";
const _AICPR = "AliasICPRecordals";
const _AICPRl = "AliasICPRecordal";
const _AM = "AllowedMethods";
const _ARN = "ARN";
const _ATKG = "ActiveTrustedKeyGroups";
const _ATS = "ActiveTrustedSigners";
const _Al = "Aliases";
const _B = "Bucket";
const _C = "Comment";
const _CA = "ConnectionAttempts";
const _CAo = "ConflictingAlias";
const _CB = "CacheBehavior";
const _CBa = "CacheBehaviors";
const _CBo = "CookieBehavior";
const _CC = "CookiesConfig";
const _CCo = "CorsConfig";
const _CDP = "ContinuousDeploymentPolicy";
const _CDPC = "ContinuousDeploymentPolicyConfig";
const _CDPI = "ContinuousDeploymentPolicyId";
const _CDPS = "ContinuousDeploymentPolicySummary";
const _CDPT = "ContinuousDeploymentPolicyType";
const _CDR = "CopyDistributionRequest";
const _CDSHC = "ContinuousDeploymentSingleHeaderConfig";
const _CDSWC = "ContinuousDeploymentSingleWeightConfig";
const _CER = "CustomErrorResponse";
const _CERu = "CustomErrorResponses";
const _CFDC = "CloudFrontDefaultCertificate";
const _CFOAIC = "CloudFrontOriginAccessIdentityConfig";
const _CFOAIS = "CloudFrontOriginAccessIdentitySummary";
const _CFR = "CreateFunctionRequest";
const _CH = "CustomHeaders";
const _CHC = "CustomHeadersConfig";
const _CKVSR = "CreateKeyValueStoreRequest";
const _CM = "CachedMethods";
const _CN = "CookieNames";
const _CNAME = "CNAME";
const _COC = "CustomOriginConfig";
const _CP = "CookiePreference";
const _CPC = "CachePolicyConfig";
const _CPCB = "CachePolicyCookieBehavior";
const _CPCC = "CachePolicyCookiesConfig";
const _CPHB = "CachePolicyHeaderBehavior";
const _CPHC = "CachePolicyHeadersConfig";
const _CPI = "CachePolicyId";
const _CPQSB = "CachePolicyQueryStringBehavior";
const _CPQSC = "CachePolicyQueryStringsConfig";
const _CPS = "CachePolicySummary";
const _CPa = "CachePolicy";
const _CR = "CallerReference";
const _CRLCR = "CreateRealtimeLogConfigRequest";
const _CS = "CertificateSource";
const _CSP = "ContentSecurityPolicy";
const _CT = "ContentType";
const _CTO = "ContentTypeOptions";
const _CTP = "ContentTypeProfile";
const _CTPC = "ContentTypeProfileConfig";
const _CTPo = "ContentTypeProfiles";
const _CTo = "CommentType";
const _CTon = "ConnectionTimeout";
const _CTr = "CreatedTime";
const _CTre = "CreateTime";
const _CU = "ComputeUtilization";
const _Ce = "Certificate";
const _Co = "Compress";
const _Coo = "Cookies";
const _D = "Description";
const _DC = "DistributionConfig";
const _DCB = "DefaultCacheBehavior";
const _DCWT = "DistributionConfigWithTags";
const _DI = "DistributionId";
const _DN = "DomainName";
const _DNn = "DnsName";
const _DRLCR = "DeleteRealtimeLogConfigRequest";
const _DRO = "DefaultRootObject";
const _DS = "DistributionSummary";
const _DTTL = "DefaultTTL";
const _E = "Enabled";
const _EAEB = "EnableAcceptEncodingBrotli";
const _EAEG = "EnableAcceptEncodingGzip";
const _EC = "ErrorCode";
const _ECMTTL = "ErrorCachingMinTTL";
const _EE = "EncryptionEntities";
const _EEn = "EncryptionEntity";
const _EK = "EncodedKey";
const _EO = "EventObject";
const _EP = "EndPoints";
const _EPn = "EndPoint";
const _ET = "ETag";
const _ETv = "EventType";
const _F = "Fields";
const _FA = "FunctionAssociations";
const _FARN = "FunctionARN";
const _FAu = "FunctionAssociation";
const _FB = "FunctionBlob";
const _FC = "FunctionCode";
const _FCa = "FailoverCriteria";
const _FCu = "FunctionConfig";
const _FEL = "FunctionExecutionLogs";
const _FEM = "FunctionErrorMessage";
const _FEO = "FunctionEventObject";
const _FLEC = "FieldLevelEncryptionConfig";
const _FLEI = "FieldLevelEncryptionId";
const _FLEPC = "FieldLevelEncryptionProfileConfig";
const _FLEPS = "FieldLevelEncryptionProfileSummary";
const _FLES = "FieldLevelEncryptionSummary";
const _FM = "FunctionMetadata";
const _FN = "FunctionName";
const _FO = "FrameOption";
const _FOL = "FrameOptionsList";
const _FOr = "FrameOptions";
const _FOu = "FunctionOutput";
const _FP = "FieldPatterns";
const _FPi = "FieldPattern";
const _FR = "FunctionRuntime";
const _FS = "FunctionStage";
const _FSu = "FunctionSummary";
const _FV = "ForwardedValues";
const _FWCTIU = "ForwardWhenContentTypeIsUnknown";
const _FWQAPIU = "ForwardWhenQueryArgProfileIsUnknown";
const _Fi = "Field";
const _Fo = "Format";
const _For = "Forward";
const _GR = "GeoRestriction";
const _GRLCR = "GetRealtimeLogConfigRequest";
const _GRT = "GeoRestrictionType";
const _H = "Header";
const _HB = "HeaderBehavior";
const _HC = "HeadersConfig";
const _HN = "HeaderName";
const _HTTPP = "HTTPPort";
const _HTTPSP = "HTTPSPort";
const _HV = "HttpVersion";
const _HVe = "HeaderValue";
const _He = "Headers";
const _I = "Integer";
const _IAMCI = "IAMCertificateId";
const _IB = "InvalidationBatch";
const _IBn = "IncludeBody";
const _IC = "IncludeCookies";
const _ICPRS = "ICPRecordalStatus";
const _IIPVE = "IsIPV6Enabled";
const _IM = "IfMatch";
const _IPIB = "InProgressInvalidationBatches";
const _IS = "ImportSource";
const _IST = "ImportSourceType";
const _ISn = "IncludeSubdomains";
const _ISnv = "InvalidationSummary";
const _ISt = "ItemSelection";
const _IT = "IsTruncated";
const _ITTL = "IdleTTL";
const _Id = "Id";
const _It = "Items";
const _K = "Key";
const _KG = "KeyGroup";
const _KGC = "KeyGroupConfig";
const _KGI = "KeyGroupId";
const _KGS = "KeyGroupSummary";
const _KPI = "KeyPairId";
const _KPIe = "KeyPairIds";
const _KSC = "KinesisStreamConfig";
const _KVS = "KeyValueStore";
const _KVSA = "KeyValueStoreAssociations";
const _KVSARN = "KeyValueStoreARN";
const _KVSAe = "KeyValueStoreAssociation";
const _KVSC = "KeyValueStoreComment";
const _KVSN = "KeyValueStoreName";
const _L = "Location";
const _LC = "LoggingConfig";
const _LDBRLCR = "ListDistributionsByRealtimeLogConfigRequest";
const _LFA = "LambdaFunctionAssociations";
const _LFARN = "LambdaFunctionARN";
const _LFAa = "LambdaFunctionAssociation";
const _LMT = "LastModifiedTime";
const _Lo = "Logging";
const _M = "Marker";
const _MB = "ModeBlock";
const _MI = "MaxItems";
const _MPV = "MinimumProtocolVersion";
const _MS = "MonitoringSubscription";
const _MTTL = "MinTTL";
const _MTTLa = "MaxTTL";
const _MTTLax = "MaximumTTL";
const _Me = "Message";
const _Mem = "Members";
const _Met = "Method";
const _N = "Name";
const _NM = "NextMarker";
const _O = "Operation";
const _OACC = "OriginAccessControlConfig";
const _OACI = "OriginAccessControlId";
const _OACOT = "OriginAccessControlOriginType";
const _OACOTr = "OriginAccessControlOriginTypes";
const _OACS = "OriginAccessControlSummary";
const _OACSB = "OriginAccessControlSigningBehaviors";
const _OACSP = "OriginAccessControlSigningProtocols";
const _OAI = "OriginAccessIdentity";
const _OCH = "OriginCustomHeader";
const _OG = "OriginGroups";
const _OGFC = "OriginGroupFailoverCriteria";
const _OGM = "OriginGroupMember";
const _OGMr = "OriginGroupMembers";
const _OGr = "OriginGroup";
const _OI = "OriginId";
const _OKT = "OriginKeepaliveTimeout";
const _OO = "OriginOverride";
const _OP = "OriginPath";
const _OPP = "OriginProtocolPolicy";
const _ORP = "OriginRequestPolicy";
const _ORPC = "OriginRequestPolicyConfig";
const _ORPCB = "OriginRequestPolicyCookieBehavior";
const _ORPCC = "OriginRequestPolicyCookiesConfig";
const _ORPHB = "OriginRequestPolicyHeaderBehavior";
const _ORPHC = "OriginRequestPolicyHeadersConfig";
const _ORPI = "OriginRequestPolicyId";
const _ORPQSB = "OriginRequestPolicyQueryStringBehavior";
const _ORPQSC = "OriginRequestPolicyQueryStringsConfig";
const _ORPS = "OriginRequestPolicySummary";
const _ORT = "OriginReadTimeout";
const _OS = "OriginShield";
const _OSP = "OriginSslProtocols";
const _OSR = "OriginShieldRegion";
const _Or = "Origin";
const _Ori = "Origins";
const _Ov = "Override";
const _P = "Paths";
const _PC = "PriceClass";
const _PI = "ProfileId";
const _PICKAFTO = "ParametersInCacheKeyAndForwardedToOrigin";
const _PIr = "ProviderId";
const _PK = "PublicKey";
const _PKC = "PublicKeyConfig";
const _PKI = "PublicKeyId";
const _PKS = "PublicKeySummary";
const _PP = "PathPattern";
const _Pa = "Path";
const _Pr = "Prefix";
const _Pre = "Preload";
const _Pro = "Protection";
const _Q = "Quantity";
const _QA = "QueryArg";
const _QAP = "QueryArgProfile";
const _QAPC = "QueryArgProfileConfig";
const _QAPu = "QueryArgProfiles";
const _QS = "QueryStrings";
const _QSB = "QueryStringBehavior";
const _QSC = "QueryStringsConfig";
const _QSCK = "QueryStringCacheKeys";
const _QSN = "QueryStringNames";
const _QSu = "QueryString";
const _R = "Resource";
const _RARN = "RoleARN";
const _RC = "ResponseCode";
const _RHC = "RemoveHeadersConfig";
const _RHP = "ResponseHeadersPolicy";
const _RHPACAH = "ResponseHeadersPolicyAccessControlAllowHeaders";
const _RHPACAM = "ResponseHeadersPolicyAccessControlAllowMethods";
const _RHPACAMV = "ResponseHeadersPolicyAccessControlAllowMethodsValues";
const _RHPACAO = "ResponseHeadersPolicyAccessControlAllowOrigins";
const _RHPACEH = "ResponseHeadersPolicyAccessControlExposeHeaders";
const _RHPC = "ResponseHeadersPolicyConfig";
const _RHPCC = "ResponseHeadersPolicyCorsConfig";
const _RHPCH = "ResponseHeadersPolicyCustomHeader";
const _RHPCHC = "ResponseHeadersPolicyCustomHeadersConfig";
const _RHPCSP = "ResponseHeadersPolicyContentSecurityPolicy";
const _RHPCTO = "ResponseHeadersPolicyContentTypeOptions";
const _RHPFO = "ResponseHeadersPolicyFrameOptions";
const _RHPI = "ResponseHeadersPolicyId";
const _RHPRH = "ResponseHeadersPolicyRemoveHeader";
const _RHPRHC = "ResponseHeadersPolicyRemoveHeadersConfig";
const _RHPRP = "ResponseHeadersPolicyReferrerPolicy";
const _RHPS = "ResponseHeadersPolicySummary";
const _RHPSHC = "ResponseHeadersPolicySecurityHeadersConfig";
const _RHPSTHC = "ResponseHeadersPolicyServerTimingHeadersConfig";
const _RHPSTS = "ResponseHeadersPolicyStrictTransportSecurity";
const _RHPXSSP = "ResponseHeadersPolicyXSSProtection";
const _RLC = "RealtimeLogConfig";
const _RLCA = "RealtimeLogConfigArn";
const _RLCN = "RealtimeLogConfigName";
const _RMSC = "RealtimeMetricsSubscriptionConfig";
const _RMSS = "RealtimeMetricsSubscriptionStatus";
const _RP = "ReferrerPolicy";
const _RPL = "ReferrerPolicyList";
const _RPP = "ResponsePagePath";
const _RT = "RestrictionType";
const _RU = "ReportUri";
const _Re = "Restrictions";
const _Ru = "Runtime";
const _S = "Staging";
const _SARN = "SourceARN";
const _SARNt = "StreamARN";
const _SB = "SigningBehavior";
const _SC = "StatusCodes";
const _SCUI = "S3CanonicalUserId";
const _SCt = "StatusCode";
const _SDC = "StreamingDistributionConfig";
const _SDCWT = "StreamingDistributionConfigWithTags";
const _SDDN = "StagingDistributionDnsNames";
const _SDI = "StagingDistributionId";
const _SDS = "StreamingDistributionSummary";
const _SHC = "SecurityHeadersConfig";
const _SHCi = "SingleHeaderConfig";
const _SLC = "StreamingLoggingConfig";
const _SO = "S3Origin";
const _SOC = "S3OriginConfig";
const _SP = "SigningProtocol";
const _SPs = "SslProtocol";
const _SR = "SamplingRate";
const _SS = "SmoothStreaming";
const _SSC = "SessionStickinessConfig";
const _SSLSM = "SSLSupportMethod";
const _ST = "StreamType";
const _STHC = "ServerTimingHeadersConfig";
const _STS = "StrictTransportSecurity";
const _STo = "SourceType";
const _SWC = "SingleWeightConfig";
const _Si = "Signer";
const _St = "Stage";
const _Sta = "Status";
const _T = "Type";
const _TC = "TrafficConfig";
const _TFR = "TestFunctionRequest";
const _TK = "TagKey";
const _TKG = "TrustedKeyGroups";
const _TKa = "TagKeys";
const _TOI = "TargetOriginId";
const _TS = "TrustedSigners";
const _TV = "TagValue";
const _Ta = "Tags";
const _Tag = "Tag";
const _UFR = "UpdateFunctionRequest";
const _UKVSR = "UpdateKeyValueStoreRequest";
const _URLCR = "UpdateRealtimeLogConfigRequest";
const _V = "Value";
const _VC = "ViewerCertificate";
const _VPP = "ViewerProtocolPolicy";
const _W = "Weight";
const _WACLI = "WebACLId";
const _WN = "WhitelistedNames";
const _WT = "WithTags";
const _XSSP = "XSSProtection";
const _b = "boolean";
const _ct = "content-type";
const _e = "etag";
const _et = "ettag";
const _f = "float";
const _i = "integer";
const _im = "if-match";
const _l = "long";
const _lo = "location";
const _m = "member";
const _s = "staging";
const _sST = "sensitiveStringType";
const _st = "string";
const _ve = '<?xml version="1.0" encoding="UTF-8"?>';
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fast_xml_parser_1.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const loadRestXmlErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
